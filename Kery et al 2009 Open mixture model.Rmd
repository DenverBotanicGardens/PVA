---
title: "Kery et al 2009 Open binomial mixture detection"
author: "Michelle DePrenger-Levin"
date: "2023-10-02"
output: html_document
---


```{r}
rm(list=ls())
library(rjags)
library(dplyr)
library(tidyr)
library(ggplot2)
library(R2jags) ## jags
library(R2WinBUGS)

```


# Data   
Replicate counts, $c_ij$ for mutliple sites $i$ and surveys $j$ within a demographically closed population    
Random effects to account for unobserved sources of variation (overdispersion) in abundance or detection    
A 'metapopulation design' because same quantities surveyed at a number of spatial replicates.   
Hierarchical model partitioning variation in c_ij into (1) spatial variation in true numbers at each site, (2) observation error because of imperfect detection.  


Kery et al. 2009 Trend estimation in populations with imperfect detection

```{r}
model_Nmix <- 
  paste("
        model{
          # Likelihood:
        
        
        
        
        
          # Priors
          loglam.site")


```


Mackenzie et al. 209 Modeling species occurrence dynamics with multiple states and imperfect detection     
```{r}
# WinBUGS 2.2.0 code for implementing species occurrence model with multiple states for green frog example. There were 4-levels of occurrence, chorus indices of size 0-3, and the problem has been coded such that the chorus index of 0 corresponds to level 4 in the WinBUGS code, other index values remain unchanged. A non-detection is therefore recorded as a ‘4’ in the data rather than a 0. Data files available by contacting Darryl at darryl@proteus.co.nz.


model {

	### Define prior distributions for the occupancy-related parameters
	Phi[1:4] ~ ddirch(alpha4[])
	for (tt in 1:T-1) {
		for (zz in 1:4) {
			TPM[tt,zz, 1:4] ~ ddirch(alpha4[])
		}
	}

	### Define detection probabilities and their prior distributions 
	for (tt in 1:T) {
		for (jj in 1:k) {
			p1[tt,jj] ~ dunif(0,1)
			p2[tt,jj,1:3] ~ ddirch(alpha3[])
			p3[tt,jj,1:4] ~ ddirch(alpha4[])


			p[tt,1,jj,1] <- p1[tt,jj]	#Pr(observe 1|true state=1)
			p[tt,1,jj,2] <- 0		#Pr(observe 2|true state=1)
			p[tt,1,jj,3] <- 0		#Pr(observe 3|true state=1)
			p[tt,1,jj,4] <- 1-p1[tt,jj] 	#Pr(observe ‘0’|true state=1)

			p[tt,2,jj,1] <- p2[tt,jj,1] 	#Pr(observe 1|true state=2)
			p[tt,2,jj,2] <- p2[tt,jj,2] 	#Pr(observe 2|true state=2)
			p[tt,2,jj,3] <- 0		#Pr(observe 3|true state=2)
			p[tt,2,jj,4] <- p2[tt,jj,3] 	#Pr(observe ‘0’|true state=2)
			
			p[tt,3,jj,1] <- p3[tt,jj,1] 	#Pr(observe 1|true state=3)
			p[tt,3,jj,2] <- p3[tt,jj,2] 	#Pr(observe 2|true state=3)
			p[tt,3,jj,3] <- p3[tt,jj,3] 	#Pr(observe 3|true state=3)
			p[tt,3,jj,4] <- p3[tt,jj,4] 	#Pr(observe ‘0’|true state=3)

			p[tt,4,jj,1] <- 0		#Pr(observe 1|true state=’0’)
			p[tt,4,jj,2] <- 0		#Pr(observe 2|true state=’0’)
			p[tt,4,jj,3] <- 0		#Pr(observe 3|true state=’0’)
			p[tt,4,jj,4] <- 1		#Pr(observe ‘0’|true state=’0’)
		}
	}

	### Impute the true occupancy state for each stop, each year (Occ[year,stop]).
	### s=number of stops
	for (ii in 1:s) {
		Occ[1,ii] ~ dcat(Phi[])
		for (tt in 1:T-1) {
			Occ[tt+1,ii] ~ dcat(TPM[tt,Occ[tt,ii], ])
		}
		for (tt in 1:T) {
			
			### Given the imputed occupancy state, what observed state was detected in
			### each survey, each year for each stop (Detect[year,stop,survey]). 
			### Note that ‘Detect’ is the only data required.
			for (jj in 1:k) {
				Detect[tt,ii,jj] ~ dcat(p[tt,Occ[tt,ii],jj, ])
			}

			### Because WinBUGS doesn’t have an ‘if’ function, we need to keep track of
			### which of the 4 occupancy states each stop was in each year.
			### State[year,state,stop] = 1 if it was in that state that year, and 0 otherwise.
			for (jj in 1:4) {
				State[tt,jj,ii] <- equals(jj,Occ[tt,ii])
			}

		}
	}
	
	### Summing up the number of stops with each chorus index each year
	for (tt in 1:T) {
		zero[tt] <- sum(State[tt,4, ])
		one[tt] <- sum(State[tt,1, ])
		two[tt] <- sum(State[tt,2, ])
		three[tt] <- sum(State[tt,3, ])
	}
}

### Some data specifying the parameters of the Dirichlet distribution, number of surveys per year, number of years and number of stops.
list(alpha4=c(1,1,1,1), alpha3=c(1,1,1),  k=3, T=5, s=280)


```



Ammend this to work with AsMi data     
MAcKenzie et al 2009 says can have missing observations so that neither a p nor a 1-p is included in the detection probability vector. Also see that probaility of nondetectino is 1 when no survey happened. As long as the missing observations are independent of the parameters, ok to not explicitly account for missing observations 
```{r}


# WinBUGS 2.2.0 code for implementing species occurrence model with multiple states for green frog example. There were 4-levels of occurrence, chorus indices of size 0-3, and the problem has been coded such that the chorus index of 0 corresponds to level 4 in the WinBUGS code, other index values remain unchanged. A non-detection is therefore recorded as a ‘4’ in the data rather than a 0. Data files available by contacting Darryl at darryl@proteus.co.nz.


model {

	### Define prior distributions for the occupancy-related parameters
	Phi[1:4] ~ ddirch(alpha4[])  ## Set to 1,1,1,1 so equally likely to be in any state
	for (tt in 1:T-1) {                      ## T = number of seasons
		for (zz in 1:4) {                      ## zz == true state??
			TPM[tt,zz, 1:4] ~ ddirch(alpha4[])   ## Transition probability matrix
		}
	}

	### Define detection probabilities and their prior distributions 
	for (tt in 1:T) {
		for (jj in 1:k) {                            ## k is number of surveys
			p1[tt,jj] ~ dunif(0,1)                     ## detection of state 1: 0-1
			p2[tt,jj,1:3] ~ ddirch(alpha3[])           ## Detection of state 2: Dirichlet where equally likely as sizes 1:3
			p3[tt,jj,1:4] ~ ddirch(alpha4[])           ## Detection of largest state 3: Dirichlet where equally likely as three sizes or no-detection


			p[tt,1,jj,1] <- p1[tt,jj]	#Pr(observe 1|true state=1)
			p[tt,1,jj,2] <- 0		#Pr(observe 2|true state=1)
			p[tt,1,jj,3] <- 0		#Pr(observe 3|true state=1)
			p[tt,1,jj,4] <- 1-p1[tt,jj] 	#Pr(observe ‘0’|true state=1)

			p[tt,2,jj,1] <- p2[tt,jj,1] 	#Pr(observe 1|true state=2)
			p[tt,2,jj,2] <- p2[tt,jj,2] 	#Pr(observe 2|true state=2)
			p[tt,2,jj,3] <- 0		#Pr(observe 3|true state=2)
			p[tt,2,jj,4] <- p2[tt,jj,3] 	#Pr(observe ‘0’|true state=2)
			
			p[tt,3,jj,1] <- p3[tt,jj,1] 	#Pr(observe 1|true state=3)
			p[tt,3,jj,2] <- p3[tt,jj,2] 	#Pr(observe 2|true state=3)
			p[tt,3,jj,3] <- p3[tt,jj,3] 	#Pr(observe 3|true state=3)
			p[tt,3,jj,4] <- p3[tt,jj,4] 	#Pr(observe ‘0’|true state=3)

			p[tt,4,jj,1] <- 0		#Pr(observe 1|true state=’0’)
			p[tt,4,jj,2] <- 0		#Pr(observe 2|true state=’0’)
			p[tt,4,jj,3] <- 0		#Pr(observe 3|true state=’0’)
			p[tt,4,jj,4] <- 1		#Pr(observe ‘0’|true state=’0’)
		}
	}

	### Impute the true occupancy state for each stop, each year (Occ[year,stop]).
	### s=number of stops
	for (ii in 1:s) {
		Occ[1,ii] ~ dcat(Phi[])
		for (tt in 1:T-1) {
			Occ[tt+1,ii] ~ dcat(TPM[tt,Occ[tt,ii], ])
		}
		for (tt in 1:T) {
			
			### Given the imputed occupancy state, what observed state was detected in
			### each survey, each year for each stop (Detect[year,stop,survey]). 
			### Note that ‘Detect’ is the only data required.
			for (jj in 1:k) {
				Detect[tt,ii,jj] ~ dcat(p[tt,Occ[tt,ii],jj, ])
			}

			### Because WinBUGS doesn’t have an ‘if’ function, we need to keep track of
			### which of the 4 occupancy states each stop was in each year.
			### State[year,state,stop] = 1 if it was in that state that year, and 0 otherwise.
			for (jj in 1:4) {
				State[tt,jj,ii] <- equals(jj,Occ[tt,ii]) ## This is testing if equal and returns 1 if true, 0 if false
			}

		}
	}
	
	### Summing up the number of stops with each chorus index each year
	for (tt in 1:T) {
		zero[tt] <- sum(State[tt,4, ])
		one[tt] <- sum(State[tt,1, ])
		two[tt] <- sum(State[tt,2, ])
		three[tt] <- sum(State[tt,3, ])
	}
}

### Some data specifying the parameters of the Dirichlet distribution, number of surveys per year, number of years and number of stops (surveys).
list(alpha4=c(1,1,1,1), alpha3=c(1,1,1),  k=3, T=5, s=280)


```

