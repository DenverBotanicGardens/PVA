---
title: "Multistate occupancy single-season"
author: "Michelle DePrenger-Levin"
date: "2023-10-03"
output: html_document
---
# Fitting a multistate occupancy model with uncertainty in Jags

<https://github.com/oliviergimenez/multistate_occupancy>     
The states are 1 for site unoccupied, 2 for occupied with no production of young ('uncertain' non-breeding state) and 3 for occupied with successful reproduction ('certain' breeding state). The observations are 0 for species not observed, 1 for species observed and 2 for species observed with young.

These data were simulated with the following parameter values:

probability that the site is occupied by non-breeders psi1 = 0.3;    
probability that the site is occupied by breeders psi2 = 0.5;     
detection probability of non-breeders p1 = 0.5;    
detection probability of breeders p2 = 0.7;    
probability of detecting evidence of reproduction, given the site is occupied with young delta = 0.8;    
number of sites R = 250.    
```{r}
library(R2jags)
library(lattice)

dat <- readr::read_csv2('https://raw.githubusercontent.com/oliviergimenez/multistate_occupancy/master/multiocc.csv', col_names = FALSE)
head(dat)
nrow(dat) # 249? Oh, first row taken as column name, needed col_names = FALSE
```


Model   
```{r}
model <- function() {

  # Define all parameters	
  # Probabilities for initial states                      ## This is the same as a Dirichlet, or at least they then sum to 1
  px0[1] <- 1 / (1 + prop[1] + prop[2])
  px0[2] <- prop[1] / (1 + prop[1] + prop[2]) # prob. of occupancy state 1
  px0[3] <- prop[2] / (1 + prop[1] + prop[2]) # prob. of occupancy state 2
  
  # Observation process
  # step 1: detection
  po1[1,1] <- 1
  po1[1,2] <- 0
  po1[1,3] <- 0
  po1[2,1] <- 1 - p1
  po1[2,2] <- p1 # detection state 1
  po1[2,3] <- 0
  po1[3,1] <- 1 - p2
  po1[3,2] <- 0
  po1[3,3] <- p2 # detection state 2
  
  # step 2: assignement
  po2[1,1] <- 1
  po2[1,2] <- 0
  po2[1,3] <- 0
  po2[2,1] <- 0
  po2[2,2] <- 1
  po2[2,3] <- 0
  po2[3,1] <- 0
  po2[3,2] <- 1 - delta
  po2[3,3] <- delta # assignment conditional on detection
  # form the matrix product
  po <- po1 %*% po2

  # State process
  px[1,1] <- 1
  px[1,2] <- 0
  px[1,3] <- 0
  px[2,1] <- 0
  px[2,2] <- 1
  px[2,3] <- 0
  px[3,1] <- 0
  px[3,2] <- 0
  px[3,3] <- 1

  for (i in 1:N){ # loop over site
    
    # state eq.
    z[i] ~ dcat(px0[1:3]) 

    # obs eq.
    for (j in 1:K){  # loop over occasion
      y[i,j] ~ dcat(po[z[i],1:3])
    }
  }

  # Prior 
  for (j in 1:2){ # use generalized logit for initial states
  log(prop[j]) <- theta[j]
  theta[j] ~ dnorm(0,1) 
  }
  p1 ~ dunif(0, 1)
  p2 ~ dunif(0, 1)
  delta ~ dunif(0, 1)

  psi1 <- prop[1] / (1 + prop[1] + prop[2]) # prob. of occupancy state 1
  psi2 <- prop[2] / (1 + prop[1] + prop[2]) # prob. of occupancy state 2
 
}

```


Data   
```{r}
N <- nrow(dat)
K <- ncol(dat)
y <- as.matrix(dat + 1)  ## why plus 1?? so that there are no more zeros?
mydatax <- list(N = N, K = K, y = y)


# Initial values
zinit <- apply(y,1,max)
init1 <- list(p1 = 0.3, theta = rnorm(2,0,1), z = zinit)
init2 <- list(p1 = 0.7, theta = rnorm(2,0,1), z = zinit)
inits <- list(init1, init2)

# Parameters to monitor
parameters <- c("psi1","psi2","p1","p2","delta")

# Fit the model
out <- jags(mydatax, inits, parameters, model, n.chains=2, n.iter=2000, n.burnin=500)
```


```{r}
# Convergence? 
traceplot(out,ask=F)

# Posterior densities 
jagsfit.mcmc <- as.mcmc(out)
densityplot(jagsfit.mcmc)

# Print results
print(out,digits = 2)
```



## Now fit to AsMi data single season   

Model   
```{r}
model <- function() {

  # Define all parameters	
  # Probabilities for initial states                      ## This is the same as a Dirichlet, or at least they then sum to 1
  px0[1] <- 1 / (1 + prop[1] + prop[2])
  px0[2] <- prop[1] / (1 + prop[1] + prop[2]) # prob. of occupancy state 1
  px0[3] <- prop[2] / (1 + prop[1] + prop[2]) # prob. of occupancy state 2
  
  # Observation process
  # step 1: detection
  po1[1,1] <- 1
  po1[1,2] <- 0
  po1[1,3] <- 0
  po1[2,1] <- 1 - p1
  po1[2,2] <- p1 # detection state 1
  po1[2,3] <- 0
  po1[3,1] <- 1 - p2
  po1[3,2] <- 0
  po1[3,3] <- p2 # detection state 2
  
  # step 2: assignement
  po2[1,1] <- 1
  po2[1,2] <- 0
  po2[1,3] <- 0
  po2[2,1] <- 0
  po2[2,2] <- 1
  po2[2,3] <- 0
  po2[3,1] <- 0
  po2[3,2] <- 1 - delta
  po2[3,3] <- delta # assignment conditional on detection
  # form the matrix product
  po <- po1 %*% po2

  # State process
  px[1,1] <- 1
  px[1,2] <- 0
  px[1,3] <- 0
  px[2,1] <- 0
  px[2,2] <- 1
  px[2,3] <- 0
  px[3,1] <- 0
  px[3,2] <- 0
  px[3,3] <- 1

  for (i in 1:N){ # loop over site
    
    # state eq.
    z[i] ~ dcat(px0[1:3]) 

    # obs eq.
    for (j in 1:K){  # loop over occasion
      y[i,j] ~ dcat(po[z[i],1:3])
    }
  }

  # Prior 
  for (j in 1:2){ # use generalized logit for initial states
  log(prop[j]) <- theta[j]
  theta[j] ~ dnorm(0,1) 
  }
  p1 ~ dunif(0, 1)
  p2 ~ dunif(0, 1)
  delta ~ dunif(0, 1)

  psi1 <- prop[1] / (1 + prop[1] + prop[2]) # prob. of occupancy state 1
  psi2 <- prop[2] / (1 + prop[1] + prop[2]) # prob. of occupancy state 2
 
}

```


Data   
```{r}
N <- nrow(dat)
K <- ncol(dat)
y <- as.matrix(dat + 1)  ## why plus 1?? so that there are no more zeros?
mydatax <- list(N = N, K = K, y = y)


# Initial values
zinit <- apply(y,1,max)
init1 <- list(p1 = 0.3, theta = rnorm(2,0,1), z = zinit)
init2 <- list(p1 = 0.7, theta = rnorm(2,0,1), z = zinit)
inits <- list(init1, init2)

# Parameters to monitor
parameters <- c("psi1","psi2","p1","p2","delta")

# Fit the model
out <- jags(mydatax, inits, parameters, model, n.chains=2, n.iter=2000, n.burnin=500)
```


```{r}
# Convergence? 
traceplot(out,ask=F)

# Posterior densities 
jagsfit.mcmc <- as.mcmc(out)
densityplot(jagsfit.mcmc)

# Print results
print(out,digits = 2)
```

