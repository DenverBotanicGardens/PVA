---
title: "EstimateDormancy"
author: "Michelle DePrenger-Levin"
date: "2023-07-25"
output: html_document
---

```{r}
rm(list=ls())
library(dplyr)
library(popbio)
library(MuMIn)
library(binr)
library(matrixStats)
require(AICcmodavg)
library(prism)
library(raster)
library(lme4)
require(DiagrammeR)
library(ggplot2)
library(MASS)
library(rstan)

# currentyr <- as.numeric(format(as.Date(Sys.Date(),format="%Y-%m-%d"), "%Y"))
currentyr <- 2022

##To change if someone other than Michelle is running code
userpath <- "C:/Users/DePrengm/"

rawdatapath <- paste(userpath, "Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_Data/", currentyr, "_Astragalus-microcymbus_RawData.csv", collapse = '', sep = '')

# For the path and start of the name of each file
savepath <- paste(userpath, "Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_AnnualReports/", currentyr, "_Astragalus-microcymbus_AnnualReport/", collapse = '', sep = '')

# Sys.Date() = "2023-05-24"
load(paste(savepath, "allpva", "2023-05-24", ".Rdata", sep = ""))

asmi.raw <- read.csv(rawdatapath, na.strings = "na")

# need to remove all plot 89, site 1 in 2020 and beyond
asmi.raw <- asmi.raw[!(asmi.raw$AsMi_plot_id == 89 & asmi.raw$year > 2019),]
asmi.raw$length[is.na(asmi.raw$length)] <- 0# Need to change all the seedling in 2014 for sites 1 and 2 to appropriate vegetative or reproductive 
asmi.raw$status[asmi.raw$AsMi_site_id<3 & asmi.raw$year == 2014 & asmi.raw$flower == 0] <- "vegetative"
asmi.raw$status[asmi.raw$AsMi_site_id<3 & asmi.raw$year == 2014 & asmi.raw$flower == 1] <- "reproductive"

# No longer adding climate data to the database
asmi.raw <- asmi.raw[,grep(paste(c("Temp","Rain","Snow","Aug.Jul"),collapse="|"), names(asmi.raw),
                           value = TRUE, invert = TRUE)]

asmi.raw$Browsing...Status[asmi.raw$Browsing...Status == "mammal" ] <- "Mammal"
asmi.raw$length[asmi.raw$length == 921] <- 21

# If there are fruit, it flowered and needs to be reproductive, not vegetative
wrongAsMidataid <- asmi.raw$AsMi_data_id[asmi.raw$status=="vegetative" & asmi.raw$fruit>0]
asmi.raw$flower[asmi.raw$AsMi_data_id %in% wrongAsMidataid] <- 1
asmi.raw$status[asmi.raw$AsMi_data_id %in% wrongAsMidataid] <- "reproductive"
```


Tremblay et al 2021 Population projections from holey matrices: Using prior information to estimate rare transition events    
Integrate prior information with Bayesian framework
Use to get irreducible and ergodic matrices, more biological realism in transition probability    
      - multinomial and beta (Dirichlet function for transition probabilities) for recruitment rates and low sample sizes (to borrow strength) from other populations. But most studies are of a single population   
      
      - A different approach is to use mark-recapture and other complex ecological models of individual survival. In mark-recaputre analysis, unobserved transitions are modeled directly. 
```{r}


```



Royle 2008 Modeling Individual Effects in the cormack-jolly-seber model: a state-space formulation    
survival in presence of imperfect detection    
     1. model for unobserved (or partially observed) individual state process - process model
     2. model for observations (independent Bernoulli trials)  
     
     Need state variables: z(i,t) for individual i and their state at time t    
     
```{r}
## Always marked y or n for fencing 
ggplot(asmi.raw, aes(year, fence, color = as.factor(AsMi_plot_id), group  = as.factor(AsMi_plot_id))) +
  geom_point()+
  geom_line()

table(asmi.raw$fence, asmi.raw$AsMi_plot_id)

# Turn AsMi into observations of alive and seen 1 or either dead or not seen 0   
## Observation model: interior 1s are known with certainty, 0s with uncertainty  
# Remove plots with fencing 
CJS <- asmi.raw %>%
  filter(fence == "n" ) %>%
  group_by(AsMi_tag_id) %>%
  arrange(year) %>%
  summarise(Site = unique(AsMi_site_id),
            Plot = unique(AsMi_plot_id),
            Tag = unique(tag_no),
            fi_t =  min(year),
            PreNAs = paste0(rep(NA, length.out = min(year) - 1995), collapse = ","),
            z_it = paste0(if_else(length > 0, 1, 0), collapse = ",")) %>%
  ungroup() %>%
  unite(z_it,  c(PreNAs, z_it), sep = ",")

## Needs NA for pre-found, all concatenated with commas

```

Simulated data from Royle 2008
```{r}
simdata.fn<-
  function(mup=0,sigmap=1.0,muphi=0,sigmaphi=1.0,nind=2000,nyear=20){
    expit<-function(x){exp(x)/(1+exp(x))}
    nper<-nind/nyear
    z<-data<-x<-matrix(NA,nrow=nind,ncol=nyear)
    first<-sort(rep(1:nyear,nper))
    p <-expit(rnorm(nind,mup,sigmap))
    phi <-expit(rnorm(nind,muphi,sigmaphi))
    for(i in 1:(nper*(nyear-1))){
      z[i,first[i]]<- x[i,first[i]]<-1
      for(j in (first[i]+1):nyear){
        z[i,j]<-rbinom(1,1,phi[i]*z[i,j-1])
        x[i,j]<-rbinom(1,1,z[i,j]*p[i])
      }
      }
    for(i in ((nyear-1)*nper + 1):nind){
      z[i,first[i]]<- x[i,first[i]]<-1
      }
    last<-first
    for(i in 1:nind){
      xx<-x[i,]
      last[i]<-max( (1:nyear)[!is.na(xx) & xx==1])
      }
    kp<-first<nyear # toss out last year of captures, no info there
    list(x=x[kp,],first=first[kp],
         nind=sum(kp),nyear=nyear,Zst=z[kp,],last=last[kp])
    }

cjsmcmc.fn<-function(nsim=40000,burn=2000){
expit<-function(x){exp(x)/(1+exp(x))}
tmp<-simdata.fn(-.5,.5,.5,.5)
nind<-tmp$nind
nyear<-tmp$nyear
x<-tmp$x
z<-tmp$Zst
first<-tmp$first
last<-tmp$last
update<-matrix(0,nrow=nind,ncol=nyear)
for(i in 1:nind){
z[i,first[i]:last[i]]<-1
if(last[i]<nyear)
update[i,(last[i]+1):nyear]<-1
}
print(date())
x[is.na(x)]<-0
z[is.na(z)]<-0
mup<- 0
sigmap<- 1
muphi<- 0
sigmaphi<- 1
alpha<-rnorm(nind,mup,sigmap)
beta<-rnorm(nind,muphi,sigmaphi)
p<-expit(alpha)
phi<-expit(beta)
out<-matrix(NA,nrow=nsim,ncol=4)
dimnames(out)<-list(NULL,c("mup","sigmap","muphi","sigmaphi"))

for(sim in 1:nsim){
  for(t in 2:nyear){
# this is wrong
#num<- (1-p)*phi*z[,t-1]
# this is correct:
num<- (1-p)*phi*z[,t-1]*( (1-phi)ˆ(ifelse(t<nyear,1,0)))
prob<-num/(num + (1-phi*z[,t-1]))
# if z[,t+1]=1 then set to 1
if(t<nyear)
prob[z[,t+1] ==1]<-1
ztmp<-rbinom(nind,1,prob)
z[update[,t]==1,t]<-ztmp[update[,t]==1]
}
nalive<-(z%*%rep(1,nyear))
totalint<- nyear - first
died<-as.numeric( (nalive -1) <totalint)
nsurv<- nalive - 1*(1-died) - died # if nalive < totalint then it died
ndet<- (x)%*%rep(1,nyear) - 1
# update all logit(p)’s by M-H
llold<-log(dbinom(ndet,nalive-1,p)) + log(dnorm(alpha,mup,sigmap))
alphacand<-rnorm(nind,alpha,.5)
pcand<-expit(alphacand)
llnew<-log(dbinom(ndet,nalive-1,pcand))+ log(dnorm(alphacand,mup,sigmap))
kp<-runif(nind)< exp(llnew-llold)
alpha[kp]<-alphacand[kp]
p[kp]<-pcand[kp]
llold<- nsurv*log(phi) + died*log(1-phi) + log(dnorm(beta,muphi,sigmaphi))
betacand<-rnorm(nind,beta,.5)
phicand<-expit(betacand)
llnew<-nsurv*log(phicand)+died*log(1-phicand)+log(dnorm(betacand,muphi,sigmaphi))
kp<-runif(nind)< exp(llnew-llold)
beta[kp]<-betacand[kp]llold<- sum(log(dnorm(alpha,mup,sigmap)))
mupc<-rnorm(1,mup,.5)
llnew<- sum(log(dnorm(alpha,mupc,sigmap)))
if(runif(1)<exp(llnew-llold))
mup<-mupc
llold<- sum(log(dnorm(alpha,mup,sigmap)))
lsigmapc<-rnorm(1,log(sigmap),.5)
sigmapc<-exp(lsigmapc)
llnew<- sum(log(dnorm(alpha,mup,sigmapc)))
if(runif(1)<exp(llnew-llold)) sigmap<-sigmapc
llold<- sum(log(dnorm(beta,muphi,sigmaphi)))
muphic<-rnorm(1,muphi,.5)
llnew<- sum(log(dnorm(beta,muphic,sigmaphi)))
if(runif(1)<exp(llnew-llold))
muphi<-muphic
llold<- sum(log(dnorm(beta,muphi,sigmaphi)))
lsigmaphic<-rnorm(1,log(sigmaphi),.5)
sigmaphic<-exp(lsigmaphic)
llnew<- sum(log(dnorm(beta,muphi,sigmaphic)))
if(runif(1)<exp(llnew-llold)) sigmaphi<-sigmaphic
out[sim,]<-c(mup,sigmap,muphi,sigmaphi)
}
print(date())
return(out[(burn+1):nsim,])
}
```

