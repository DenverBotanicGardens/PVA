---
title: "AsMi_annual report"
author: "Michelle DePrenger-Levin"
date: "Tuesday, October 27, 2015"
output:
  html_document: default
  word_document: default
---
The git remote is "AsMiPVA"
AsMiPVA


2020 - convert everything to z-scores (mean of 0, SD) All values (x-mean)/SD

On Onedrive "C:\Users\DePrengm\OneDrive - Denver Botanic Gardens\P drive\hackathon\GitPVA\"

```{r}
# library(reshape2) 
library(dplyr)
library(tidyr)
library(ggplot2)
# library(psych)
library(popbio)
library(devtools)
library(sciplot)
library(plotrix)
library(scales)
# library(plyr)
library(digest)
library(RCurl)
# library(roxygen2)  # only need if files have roxygen2 comments
# install_github(repo = "prism", username = "ropensci")
library(prism)
# prism_set_dl_dir("Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/PRISM_asmiclimate")
# library(rgdal) Will go away in 2023 https://r-spatial.org/r/2022/04/12/evolution.html and https://github.com/r-spatial/evolution rgdal: version: 1.6-2, (SVN revision 1183)

library(raster)
library(Rmisc)
# library(data.table)
# library(survminer)

library(car) 

# AIC
require(AICcmodavg)
library(lme4)
library(lattice)

#Plots and figures
library(DiagrammeR)
library(patchwork)

```


Remove all variables, keep functions
```{r reset values, eval = FALSE}
rm(list = setdiff(ls(), lsf.str()))
rm(list = ls())
```

summarySE function borrowed from http://www.cookbook-r.com/Manipulating_data/Summarizing_data/  
Function for t.tests, for annual lambdas
```{r}

# StagePVA_Function.R
source_url("https://raw.githubusercontent.com/DenverBotanicGardens/PVA/master/StagePVA_Function.R")
# script <- getURL("https://raw.githubusercontent.com/DenverBotanicGardens/PVA/master/StagePVA_Function.R",ssl.verifypeer = FALSE)
# eval(parse(text = script))

# StagePVA_simple for one plot at a time function is StagePVA_single
source_url("https://raw.githubusercontent.com/DenverBotanicGardens/PVA/master/StagePVA_simple.R")
# script <- getURL("https://raw.githubusercontent.com/DenverBotanicGardens/PVA/master/StagePVA_simple.R",ssl.verifypeer = FALSE)
# eval(parse(text = script))

# ### Function for lambda and 
# requires library(popbio)    
# x is the list of matrices, i.e. notfenced.Site.matrix$"26",     
# 					or fenced.Site.matrix$"19"[2:17])    
# y is the start year    
# z is the start of the last transition

lmdSD <- function(x,y,z){
  
  startyr <- min(as.numeric(names(x)))
	yrs <- startyr:z
	st <- match(c(y,z),yrs)
	
	lambdaAll <- c()
	for(i in c(y:z)){
		lambdaAll <- cbind(lambdaAll,eigen.analysis(x[[as.character(i)]])$lambda)
	}	
	StandDev <- sqrt(var(c(lambdaAll)))	#Standard Deviation
	cbind(lmda = lambda(mean(x[st[1]:st[2]])),SD = StandDev)
}	

lmdAn <- function(x,y,z){
	lambdaAll <- c()
	for(i in c(y:z)){
		lambdaAll <- cbind(lambdaAll,eigen.analysis(x[[as.character(i)]])$lambda)
	}	
	lambdaAll
}
```


# Methods, Bayesian multiple types of data to estimate parameters and latent states   
```{r}
grViz("digraph integrated_pop {
      
      # digraph = directed, graph = undirected, graphID
      graph [compound = true, color = blue, rankdir = LR]
      
      # node definitions with substituted label text
      node [shape = circle, fontname = Helvetica]
      # Demographic monitoring
      a [label = '@@1-1']
      b [label = '@@1-2']
      c [label = '@@1-3']
      d [label = '@@1-4']
      
      # Within season monitoring
      e [label = '@@2-1']
      f [label = '@@2-2']
      g [label = '@@2-3']
      h [label = <&Phi;<SUB>stn_j</SUB>>]
      
      # name must start with 'cluster_'
      subgraph cluster_demography {
        graph [style = dashed, color = Sienna]
        rank = same; a;d;
        rank = same; b; c;
        a -> {b c}
        b -> c
        c -> a [style = dashed, color = LimeGreen]
        a -> d
        b -> d
        c -> d
        c -> b [color = red]
        d -> b [color = red]
        d -> c [color = red]
        
        label = 'Demography'
      }
      
      subgraph cluster_seasonal {
        graph [style = dashed, color = Sienna]
        e -> {f g}
        f -> g
        
        label = 'Within season'
      }
      
      subgraph cluster_detection {
        graph [style = dashed, color = Sienna]
        h
        
        label = 'Detection probability'
      }
      
    h -> {e f g} [lhead = cluster_seasonal] [style = dashed, color = Indigo, dir = both]
    h -> d [color = Indigo]
    # f -> d [ltail = cluster_demography, lhead = cluster_seasonal] 
    }
      
      [1]: c('Seedling','Vegetative','Reproductive','Dormant')
      [2]: c('Seedling','Vegetative','Reproductive')
      ")

```



# Download raw_data 
<https://research.botanicgardens.org/admin/demographics/asmi/reports/raw_data.php>   
Save all sites, all data, and set to 20 years allowed dormant (or all possible years)    
Put the new data in folder currentyr_asmi and name it RawData_currentyr 
```{r}
currentyr <- as.numeric(format(as.Date(Sys.Date(),format="%Y-%m-%d"), "%Y"))

##To change if someone other than Michelle is running code
userpath <- "C:/Users/DePrengm/"

rawdatapath <- paste(userpath, "Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_Data/", currentyr, "_Astragalus-microcymbus_RawData.csv", collapse = '', sep = '')

asmi.raw <- read.csv(rawdatapath, na.strings = "na")

# need to remove all plot 89, site 1 in 2020 and beyond
asmi.raw <- asmi.raw[!(asmi.raw$AsMi_plot_id == 89 & asmi.raw$year > 2019),]


# For the path and start of the name of each file
savepath <- paste(userpath, "Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_AnnualReports/", currentyr, "_Astragalus-microcymbus_AnnualReport/", collapse = '', sep = '')


asmi.raw$length[is.na(asmi.raw$length)] <- 0

# For plots that didn't start in 1995 !!! All new plants are listed as seedlings in 2014 and none should
table(asmi.raw$AsMi_plot_id[asmi.raw$AsMi_site_id==1], 
      asmi.raw$status[asmi.raw$AsMi_site_id==1], 
      asmi.raw$year[asmi.raw$AsMi_site_id==1])

table(asmi.raw$AsMi_plot_id[asmi.raw$AsMi_site_id==2], 
      asmi.raw$status[asmi.raw$AsMi_site_id==2], 
      asmi.raw$year[asmi.raw$AsMi_site_id==2])

# Site 26 had two plots added later; Plots 238 and 300 were added in 1996 with no seedlings! good!;  plot 598 was added in 2004, no seedlings, good!  
table(asmi.raw$AsMi_plot_id[asmi.raw$AsMi_plot_id %in% c(238,300,598)], 
      asmi.raw$status[asmi.raw$AsMi_plot_id %in% c(238,300,598)],
      asmi.raw$year[asmi.raw$AsMi_plot_id %in% c(238,300,598)])

# Need to change all the seedling in 2014 for sites 1 and 2 to appropriate vegetative or reproductive 
asmi.raw$status[asmi.raw$AsMi_site_id<3 & asmi.raw$year == 2014 & asmi.raw$flower == 0] <- "vegetative"
asmi.raw$status[asmi.raw$AsMi_site_id<3 & asmi.raw$year == 2014 & asmi.raw$flower == 1] <- "reproductive"

# No longer adding climate data to the database
asmi.raw <- asmi.raw[,grep(paste(c("Temp","Rain","Snow","Aug.Jul"),collapse="|"), names(asmi.raw),
                           value = TRUE, invert = TRUE)]

table(asmi.raw$year, asmi.raw$AsMi_site_id)
table(asmi.raw$year, asmi.raw$AsMi_plot_id)
table(asmi.raw$Browsing...Status)
asmi.raw$Browsing...Status[asmi.raw$Browsing...Status == "mammal" ] <- "Mammal"
asmi.raw[asmi.raw$Browsing...Status ==""& !is.na(asmi.raw$Browsing...Status),]
asmi.raw[is.na(asmi.raw$AsMi_data_id),]
asmi.raw <- asmi.raw[!is.na(asmi.raw$AsMi_data_id),] # remove any rows with NA for data_id

# Which plot # go with which site
plotsXsite <- as.data.frame(table(asmi.raw$AsMi_plot_id,asmi.raw$AsMi_site_id))
plotsXsite[plotsXsite$Freq > 0,]

# one blank row at the end of the csv download, gone by 2021
asmi.raw[asmi.raw$status == "",]
# asmi.raw <- asmi.raw[asmi.raw$status != "",]
asmi.raw$status <- factor(asmi.raw$status)
table(asmi.raw$status)

#reset factors of browsing to eliminate " "
# asmi.raw$Browsing...Status[asmi.raw$Browsing...Status == "mammal"] <- "Mammal"
asmi.raw$Browsing...Status <- factor(asmi.raw$Browsing...Status)

#reset factors for fence
asmi.raw$fence <- factor(asmi.raw$fence)
table(asmi.raw$fence)

asmi.raw[asmi.raw$length>90 & !is.na(asmi.raw$length),] 
asmi.raw$length[asmi.raw$length == 921] <- 21

# If there are fruit, it flowered and needs to be reproductive, not vegetative
asmi.raw[asmi.raw$status=="vegetative" & asmi.raw$fruit>0,] # 5 times in 2020
wrongAsMidataid <- asmi.raw$AsMi_data_id[asmi.raw$status=="vegetative" & asmi.raw$fruit>0]
asmi.raw$flower[asmi.raw$AsMi_data_id %in% wrongAsMidataid] <- 1
asmi.raw$status[asmi.raw$AsMi_data_id %in% wrongAsMidataid] <- "reproductive"
asmi.raw[asmi.raw$AsMi_data_id %in% wrongAsMidataid,]

# Years of study in the abstract
length(1995:currentyr)
```

Instantaneous rates of change  <https://www.webpages.uidaho.edu/wlf448/Peterson2.htm>  
if population doubles each year   
R = 2 = finite rate of growth yearly  
R = $e^r$ = 2   
r = ln R = 0.693
```{r}
R <- 2
r <- log(R)

```

UTM Zone 13 from ArcGIS
```{r}
# asmilatlong <- read.csv("Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/Asmi_Word/2016_asmi/UTM_asmiplots.csv")
asmilatlong <- read.csv(paste(userpath, "Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_AnnualReports/2016_Astragalus-microcymbus_AnnualReport/UTM_asmiplots.csv", sep="", collapse = ""))

# Convert from UTM to lat/long
asmi.ll <- spTransform(SpatialPoints(cbind(asmilatlong$Easting,asmilatlong$Northing), 
                                     proj4string = CRS("+proj=utm +zone=13 + datum=WGS84")), 
                       CRS("+proj=longlat +datum=WGS84"))

asmiLL <- data.frame(raster::coordinates(asmi.ll),asmilatlong$Tag__,asmilatlong$Tag_Commen)

# only if made it for current year, then load here and skip the climate chunks that follow
load( paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_Data/asmi.climate", currentyr,".Rdata", sep=""))
load(paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_Data/asmi.annual", currentyr,".Rdata", sep=""))
load(paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_Data/asmi.season", currentyr,".Rdata", sep=""))
load(paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_Data/asmi.season.wide", currentyr,".Rdata", sep=""))

```
asmi.c from github    Plot Site   Creek   tmin        Site.1 tmax Precip Year Month Prev12


### Drop to bottom to download new climate data!! and to make and save annual, seasonal data

```{r}
## I think wants wide instead of long as in asmi.annual
# asmi.c <- asmi.climate
asmi.c <- asmi.annual %>%
  pivot_wider(names_from = Variable, values_from = Value) %>%
  dplyr::mutate(across(ppt:tmin, scale, .names = "{.col}_scaled")) %>%
  mutate(Year = Prev12)
  

# Get a list of sites and plots per Creek to merge with asmi.c
plots.site <- asmi.raw[!duplicated(asmi.raw$AsMi_plot_id),c("AsMi_plot_id","AsMi_site_id")]
plots.site <- plots.site[complete.cases(plots.site),]
plots.site$Creek <- "SouthBeaver"
plots.site$Creek[plots.site$AsMi_site_id < 3] <- "Cebolla"

asmi.c <- merge(plots.site, asmi.c, by.x="AsMi_plot_id", by.y="Plot")
asmi.c <- asmi.c %>%
  dplyr::rename(Plot = AsMi_plot_id, SiteID = AsMi_site_id)

asmi.season.wide %>%
  ungroup() %>% ## but it's not grouped, maybe was taking as each row is a group without this call?
  dplyr::mutate(across(ppt_fall:tmin_winter, .fns = scale)) %>% #, .names = "{.col}_scaled")) %>%
  # pivot_longer(cols = ppt_fall_scaled:tmin_winter_scaled, names_to = "VarSeason",
  pivot_longer(cols = ppt_fall:tmin_winter, names_to = "VarSeason",
               values_to = "Value") %>%
  left_join(plots.site, by = c('Plot' = 'AsMi_plot_id')) %>%
  separate(VarSeason, c("Variable","season"), sep = "_") %>%
  ggplot(  aes(Prev12, Value, color = site))+
    geom_point()+
    stat_smooth()+
    theme_bw()+
    facet_grid(Variable ~ season + Creek)

```


```{r}

# 1986 to currentyr
asmi.c %>% 
  group_by(Creek) %>%
  dplyr::summarise(across(ppt:tmin, mean))


asmi.c %>%
  pivot_longer(cols = ppt_scaled:tmin_scaled, names_to = "variable", values_to = "value") %>%
ggplot(  aes(Prev12, value, color = site, group = site))+
  geom_point()+
  stat_smooth()+
  facet_grid(Creek~variable)

asmi.c %>%
  pivot_longer(cols = ppt:tmin, names_to = "variable", values_to = "value") %>%
  group_by(Creek, variable) %>%
  dplyr::summarise(mean1980_2022 = mean(value), sd1980_2022 = sd(value)) 

asmi.c %>%
  pivot_longer(cols = ppt:tmin, names_to = "variable", values_to = "value") %>%
  filter(Year > 1994) %>%
  group_by(Creek, variable) %>%
  dplyr::summarise(mean1995_2022 = mean(value), sd1995_2022 = sd(value)) 
```


## ---------------------------------------- Paper Analysis -------------------------------------------------

# Annual precipiation average per year
```{r}
length(1995:currentyr)

creekyear.avg <- aggregate(ppt~Creek+Prev12, data = asmi.c[asmi.c$Year > 1994,], mean)
creekyear <- aggregate(ppt~Creek+Prev12, data = creekyear.avg, sum)

#ppt mm
mean(creekyear$ppt[creekyear$Creek == "Cebolla"])
mean(creekyear$ppt[creekyear$Creek == "SouthBeaver"])
mean(creekyear$ppt)
```


Table 1:Demographic data of Astragalus microcymbus within the South Beaver Creek and Cebolla Creek drainages near Gunnison, Colorado. (a) Average number of individuals with above ground growth (AGG) followed by total individuals (AGG and dormant) per plot. (b) Percent of reproductive individuals followed by average reproductive individuals per plot. Site 1 is Cebolla Creek Mid and site 2 is Cebolla Creek north. Standard errors are shown in parentheses.
```{r}
#AGG
#length of group when the plant had a length greater than zero
alive <-aggregate(length ~ AsMi_plot_id + year + AsMi_site_id + fence, 
                  data = asmi.raw, function(x) length(x[x>0 & !is.na(x)])) 

totalyr <- aggregate(length~AsMi_site_id, data = alive[alive$year == currentyr,], sum)
sum(totalyr$length[1:2])
sum(totalyr$length[3:6])


alive2 <- do.call(rbind,lapply(split(asmi.raw, list(asmi.raw$AsMi_plot_id, asmi.raw$year), drop=TRUE), function(plotyr){
  AGG <- length(unique(plotyr$AsMi_tag_id[plotyr$length > 0 & !is.na(plotyr$length)]))
  data.frame(Plot = plotyr$AsMi_plot_id[1], Year = plotyr$year[1], Site = plotyr$AsMi_site_id[1],
             Fence = plotyr$fence[1], AGG, Alive = length(unique(plotyr$AsMi_tag_id[plotyr$status != "dead"])))
}))


# What percent of original size are all plots?
totPOrig <- do.call(rbind,lapply(split(alive2,alive2$Plot),
                                  function(plot){
                                    first <- plot$AGG[plot$Year==min(plot$Year)]
                                    last <- plot$AGG[plot$Year==max(plot$Year)]
                                    percent <- last/first
                                    out <- data.frame(plot[plot$Year==min(plot$Year),],
                                                      plot[plot$Year==max(plot$Year),
                                                           c("Year","AGG","Alive")],
                                                      percent)
                                    out
                                    }))

outdata <- do.call(rbind,lapply(unique(totPOrig$Site), function(pl){
  data.frame(totPOrig[totPOrig$Site == pl,],average = mean(totPOrig$percent[totPOrig$Site == pl]))
       }))
outdata[with(outdata, order(percent,Site,Fence)),]
aggregate(AGG ~ Site, data = outdata, sum)

aggregate(AGG.1 ~ Site, data = outdata, sum)

#AGG and dormant
aggdorm <- aggregate(status ~ AsMi_plot_id +year + AsMi_site_id  + fence,
                     data = asmi.raw, function(x) length(x[x != "dead" & !is.na(x)]))


## Figure 2: Number of AsMi with AGG

ggsave(paste(savepath, "Fig2AGG.jpg", sep = ""),
(alive %>%
  mutate(Creek = case_when(AsMi_site_id < 3 ~ "Cebolla",
                           AsMi_site_id > 3 ~ "South Beaver")) %>%
ggplot(  aes(as.factor(year), length)) + 
  geom_boxplot()+
  ylab("Individuals with AGG per plot")+
  xlab("Year")+
  theme_bw()+
  facet_wrap(~as.factor(AsMi_site_id) + Creek, scales = "free")+
  scale_color_discrete(guide = "none")+ 
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  ggtitle("a)"))
/

(aggdorm %>%
  mutate(Creek = case_when(AsMi_site_id < 3 ~ "Cebolla",
                           AsMi_site_id > 3 ~ "South Beaver")) %>%
   filter(if_else(AsMi_site_id > 3, year > 1995, year > 2014)) %>%
   filter(if_else(AsMi_plot_id == 598, year > 2004, year > 1995)) %>%
   filter(if_else(AsMi_plot_id %in% c(238,300), year > 1996, year > 1995)) %>%
   filter(if_else(AsMi_plot_id == 89, year < 2020, year < currentyr)) %>% ## Tags removed in 2020 by unknown
   filter(year < currentyr) %>%
  ggplot(  aes(as.factor(year), status)) + 
  geom_boxplot()+
  ylab("Individuals with AGG and dormant per plot")+
  xlab("Year")+
  theme_bw()+
  facet_wrap(~as.factor(AsMi_site_id) + Creek, scales = "free")+
  scale_color_discrete(guide = "none")+ 
   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
   ggtitle(("b)"))), 
width=275, height=250,units='mm', dpi=300)



```

#Fluctuations  
```{r}

#AGG
alive.site <-aggregate(length ~ year + AsMi_site_id + fence, 
                  data = asmi.raw, function(x) length(x[x>0 & !is.na(x)]))


#AGG and dormant
aggdorm.site <- aggregate(status ~ year + AsMi_site_id  + fence,
                     data = asmi.raw, function(x) length(x[x != "dead" & !is.na(x)]))


PercentAlive <- lapply(split(alive.site, alive.site$AsMi_site_id), function(x){
  nofence <- x$length[x$year == max(x$year)&
                        x$fence=="n"]/x$length[x$year==min(x$year)&x$fence=="n"]
  fence <- x$length[x$year == max(x$year)&
                      x$fence=="y"]/x$length[x$year==min(x$year)&x$fence=="y"]
  cbind(nofence,fence)

  })

tbl1a.1 <- summarySE(alive, measurevar="length", groupvars=c("AsMi_site_id", "year"))

tbl1a.2 <- summarySE(aggdorm, measurevar="status", groupvars=c("AsMi_site_id", "year"))

sites <- unique(tbl1a.1$AsMi_site_id)

tbl1.1 <- lapply(sites, function(x){
  paste(round(tbl1a.1[tbl1a.1$AsMi_site_id == x,"length"],2)," (",
        round(tbl1a.1[tbl1a.1$AsMi_site_id == x,"se"],2), ")", sep="")
})

tbl1.2 <- lapply(sites, function(x){
  paste(round(tbl1a.2[tbl1a.2$AsMi_site_id == x,"status"],2)," (",
        round(tbl1a.2[tbl1a.2$AsMi_site_id == x,"se"],2), ")", sep="")
})

tbl1a <- lapply(1:6, function(x){
  data.frame(tbl1.1[[x]],tbl1.2[[x]])
  })


Table1 <- data.frame(tbl1a[[3]],tbl1a[[4]],tbl1a[[5]],tbl1a[[6]])
names(Table1) <- c("Site 05 (5 plots)"," ","Site 15 (4 plots)"," ",
                   "Site 19 (5 plots)"," ","Site 26 (5 plots)"," ")

write.table(Table1, file=paste(savepath,"Table1a_SouthBeaverCreek.csv", collapse = '', sep = ''), sep=",", row.names=FALSE, col.names = TRUE)

Table1_Cebolla <- data.frame(tbl1a[[1]],tbl1a[[2]])
names(Table1_Cebolla) <- c("Site 1 (5 plots)"," ","Site 2 (6 plots)"," ")

write.table(Table1_Cebolla, file=paste(savepath,"Table1a_CebollaCreek.csv", collapse = '', sep = ''), sep=",", row.names=FALSE, col.names = TRUE)


# Percent and total reproductive
# percent reproductive, return 0 if no 
prep <- aggregate(flower~AsMi_plot_id+year+AsMi_site_id +fence,
                  data = asmi.raw[asmi.raw$length > 0 & !is.na(asmi.raw$length),],
                  function(x){
                    if(length(x)>0){
                      sum(x,na.rm = TRUE)/length(x)
                    } else {
                        0
                      }
                  })
tbl1b.1 <- summarySE(prep, measurevar="flower", groupvars=c("AsMi_site_id","year"))

# Years when there were no reproductive individuals  
# Episodic fruit production paragraph
prep[prep$flower==0,]
annual_SBC <- aggregate(flower~year, data=prep[prep$AsMi_site_id>3,], sum)
zero_annual <- data.frame(num = nrow(annual_SBC[annual_SBC$flower == 0,]),
                          percent = nrow(annual_SBC[annual_SBC$flower == 0,])/nrow(annual_SBC))


do.call(rbind,zero_annual)

annual_site <- aggregate(flower~AsMi_site_id+year, data=prep, sum)
zero_site <- lapply(split(annual_site, annual_site$AsMi_site_id), function(x){
  numberof <- nrow(x[x$flower == 0,])
  percent <- nrow(x[x$flower == 0,])/nrow(x)
  data.frame(numberof,percent)
})
zero_all <- do.call(rbind,zero_site)
mean(zero_all$numberof[3:6]) # average number of years with no reproduction

```


```{r}
#sites above
#percent reproductive 
tbl1.3 <- lapply(sites, function(x){
  paste(round(tbl1b.1[tbl1b.1$AsMi_site_id == x,"flower"],3)*100,"% (",
        round(tbl1b.1[tbl1b.1$AsMi_site_id == x,"se"],3)*100, "%)", sep="")
})

tbl1.3[[3]]

#total reproductive
totrep <- aggregate(flower ~ AsMi_plot_id +year + AsMi_site_id  + fence,
                    data = asmi.raw[asmi.raw$length > 0 & !is.na(asmi.raw$length),], 
                    function(x) sum(x, na.rm = TRUE))


tbl1b.2 <- summarySE(totrep, measurevar="flower",groupvars=c("AsMi_site_id","year"))

tbl1.4 <- lapply(sites, function(x){
  paste(round(tbl1b.2[tbl1b.2$AsMi_site_id == x,"flower"],2)," (",
        round(tbl1b.2[tbl1b.2$AsMi_site_id == x,"se"],2), ")", sep="")
})

tbl1b <- lapply(1:6, function(x){
  data.frame(tbl1.3[[x]], tbl1.4[[x]])
  })

Table1b <- data.frame(tbl1b[[3]],tbl1b[[4]],tbl1b[[5]],tbl1b[[6]])
names(Table1b) <- c("Site 05 (5 plots)"," ","Site 15 (4 plots)"," ",
                   "Site 19 (5 plots)"," ","Site 26 (5 plots)"," ")

write.table(Table1b, file=paste(savepath,"Table1b_SouthBeaverCreek.csv", sep=""), sep=",", row.names=FALSE, col.names = TRUE)

Table1b_Cebolla <- data.frame(tbl1b[[1]],tbl1b[[2]])
names(Table1b_Cebolla) <- c("Site 1 (5 plots)"," ","Site 2 (6 plots)"," ")

write.table(Table1b_Cebolla, file=paste(savepath,"Table1b_CebollaCreek.csv", sep=""), sep=",", row.names=FALSE, col.names = TRUE)
```

#Correlated biotic factors

Table 3: Biotic factors correlated among the percent browsed individuals in the current year, density of reproductive individuals in the current year, fruit production in the current year, and the percent of reproductive individuals and above ground growth (AGG) in the current and previous year of Astragalus microcymbus per year (1995-2014) within the South Beaver Creek drainage ....Significant PCC are indicated with an asterisk (p-value < 0.05).  

Plot Summary (weather data is prev. Aug through currrent Jul)   
Total.Plants are AGG and dormant    
Total.Alive is AGG   
X..Flowered must be percent flowered and    
X..Flowered.1 is number flowered

#Save new annual data in folder titled "<current year>_asmi" and name the file "PlotSummary_<current year>"  pre-Teams
# Save new annual data in folder "~\Denver Botanic Gardens\Conservation - General\AllProjectsBySpecies\Astragalus microcymbus\Astragalus-microcymbus_Data\" and title them:     
     "<current year>_Astragalus-microcymbus_PlotSummary.csv"   
     "<current year>_Astragalus-microcymbus_RawData.csv"
```{r}
plotdatapath <- paste(userpath, "Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_Data/",
        currentyr,"_Astragalus-microcymbus_PlotSummary.csv",
                      collapse = '', sep = '')
ps.asmi <- read.csv(plotdatapath)
# Don't need the climate data from database, will download from PRISM
ps.asmi <- ps.asmi %>%
  dplyr::select(Year:Fence) ##ps.asmi[,1:11] # old climate data that isn't updated in the database

# Have data for all years but were only in place in the listed years
ps.asmi$Year[ps.asmi$Plot == 89] # 2014-2019
ps.asmi$Year[ps.asmi$Plot == 598] # 2004-currentyr
ps.asmi$Year[ps.asmi$Plot == 300] # 1996-currentyr

# remove rows with summaries of non-existent plots like 89 after 2019
ps.asmi <- ps.asmi[!(ps.asmi$Plot == 89 & ps.asmi$Year > 2019),]
ps.asmi <- ps.asmi[!(ps.asmi$Site < 3 & ps.asmi$Year < 2014),]
ps.asmi <- ps.asmi[!(ps.asmi$Plot == 598 & ps.asmi$Year < 2004),]
ps.asmi <- ps.asmi[!(ps.asmi$Plot == 300 & ps.asmi$Year < 1996),]
ps.asmi <- ps.asmi[!(ps.asmi$Plot == 238 & ps.asmi$Year < 1996),]


## What was the total population size in plots that eventually are fenced?
ps.asmi %>%
  filter(Site == 5) %>%
  group_by(Fence, Year) %>%
  dplyr::summarise(TotalPlant = sum(Total.Plants), 
                   AGG = sum(Total.Alive), .groups = "keep") %>%
  print(n=56)
# aggregate(Total.Plants ~ Fence + Year, data = ps.asmi[ps.asmi$Site == 5,], sum)

# remove the moniker of 'y' from fenced plots before they are fenced.
ps.asmi$Fence[ps.asmi$Year<2006] <- 'n'

ps.asmi$Creek <- "SouthBeaver"
ps.asmi$Creek[ps.asmi$Site < 3] <- "Cebolla" 
ps.asmi$Creek <- as.factor(ps.asmi$Creek)

## Number of individuals alive in current year compared to start of Cebolla Creek == 2014
# ps.asmi %>%
#   filter(Site < 3) %>%
#   group_by(Fence, Site, Year) %>%
#   dplyr::summarise(sum(Total.Plants))
lapply(split(ps.asmi[ps.asmi$Site < 3,], list(ps.asmi$Fence[ps.asmi$Site < 3],  
                                                   ps.asmi$Site[ps.asmi$Site < 3]), drop=TRUE), 
       function(x){
         aggregate(Total.Plants ~ Year, data = x, sum)/sum(x$Total.Plants[x$Year == 2014])*100
         }) 

lapply(split(ps.asmi[ps.asmi$Site < 3,], list(ps.asmi$Fence[ps.asmi$Site < 3],  
                                                   ps.asmi$Site[ps.asmi$Site < 3]), drop=TRUE), 
       function(x){
         aggregate(Total.Alive ~ Year, data = x, sum)/sum(x$Total.Plants[x$Year == 2014])*100
         }) 


aggregate(Total.Alive ~ Fence + Year + Site, data = ps.asmi[ps.asmi$Site < 3,], sum)

```




#AIC  Information Criteria   
Table 2: linear regression model performance 
AIC = -2L + 2k   
  L is loglikelihood   
  k is number of parameters     
Compare all models at the same time, instead of stepping through pairwise comparisons of tests. 
Flawed still, too many factors/parameters, not enough data. 

Just look at differences separating site and not, separate plot or not. 
Can look at these and then work forward to test predictive on new data (like the BLM or sites we visit this year)

# Table 3 Differences by site, fencing, and within site among plots?
Survival instead of AGG 
```{r}

asmi.merged %>%
  mutate(Creek = case_when(AsMi_site_id < 3 ~ "Cebolla",
                           AsMi_site_id > 3 ~ "South Beaver")) %>%
ggplot(  aes(year.y, surv, color = site))+
  geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE)+
  geom_jitter(shape = "|", height=0)+
  facet_wrap(~Creek, scales = "free_x")+
  theme_light()+
  xlab("Year")+
  ylab("Survival")

Fig4asurvCreekBr <- asmi.merged %>%
  filter(!is.na(browsing.x)) %>%
ggplot( aes(length.x, surv, color = as.factor(browsing.x)))+
  geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE)+
  geom_point(shape = "|")+
  theme_light()+
  xlab("Length of longest stem (cm)")+
  facet_grid(status.x ~ Creek )+
  scale_color_discrete("Browsing")+
  ylab("Survival")+
  ggtitle("a)")

Fig4asurvCreek <- asmi.merged %>%
ggplot( aes(length.x, surv, color = site))+
  geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE)+
  geom_point(shape = "|")+
  theme_light()+
  xlab("Length of longest stem (cm)")+
  facet_wrap(~ status.x, nrow=3 )+
  ylab("Survival")

asmi.merged %>%
ggplot( aes(year.y, surv, color = fence))+
  geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE)+
  geom_point(shape = "|")+
  theme_light()+
  xlab("Year")+
  facet_wrap(~Creek, scales = "free_x")+
  ylab("Survival")


glm1 <- glm(surv ~ year.y, family = binomial, data = asmi.merged)
glm2 <- glm(surv ~ year.y*as.factor(site), family = binomial, data = asmi.merged)
glm3 <- glm(surv ~ year.y*Creek, family = binomial, data = asmi.merged) 
glm4 <- glm(surv ~ year.y*fence, family = binomial, data = asmi.merged)
glm5 <- glm(surv ~ 1, family = binomial, data = asmi.merged)
glm6 <- glm(surv ~ as.factor(site), family = binomial, data = asmi.merged)
glm7 <- glm(surv ~ Creek, family = binomial, data = asmi.merged) 
glm8 <- glm(surv ~ fence, family = binomial, data = asmi.merged)

glm.list <- list(glm1,glm2,glm3,glm4,glm5,glm6,glm7,glm8)
glm.names <- as.character(unlist(lapply(glm.list,formula)))
(glm.results <- aictab(glm.list, modnames=glm.names))

#evidence ratio 
for(i in 2:length(glm.list)){
  print(exp(0.5*glm.results$Delta_AICc[i]))
}

```
Year and site differ for the total allive with AGG. 

# Climate factors  
```{r}

## use scaled numbers!
asmi.merged <- asmi.raw %>%
  group_by(AsMi_tag_id, AsMi_plot_id, AsMi_site_id, fence) %>%
  left_join(asmi.raw, by = c("AsMi_tag_id", "AsMi_plot_id", "AsMi_site_id", "fence")) %>%
  dplyr::select(AsMi_tag_id:status.x, AsMi_plot_id:fence, year.y:status.y) %>%
  filter(year.x == year.y-1) %>% # .x is year t, .y is year t+1
  filter(length.x > 0) %>%
  filter(!is.na(length.x)) %>%
  # left_join(asmi.c, by = c("AsMi_plot_id" = "Plot", 
  #                                    "year.y" = "Year")) %>%
  left_join(asmi.season.wide,  by = c("AsMi_plot_id" = "Plot",
                                      "year.y" = "Prev12")) %>%
  mutate(surv = case_when(length.y > 0 & !is.na(length.y) ~ 1,
                          length.y == 0 | is.na(length.y) ~ 0)) %>%
  mutate(Creek = case_when(AsMi_site_id < 3 ~ "Cebolla",
                           AsMi_site_id > 3 ~ "South Beaver")) 

ggplot(asmi.merged, aes(length.x, length.y, color = site))+
  geom_point()+
  stat_smooth(method="glm")

ggsave(paste(savepath, "FigureAGGsurv.jpg", sep = ""),
ggplot(asmi.merged, aes(length.x, surv))+ #, color = site))+
  geom_point(pch="|")+
  facet_grid(Creek~status.x)+
  theme_bw()+
  ylab("survival")+
  xlab("Length of longest stem (cm)")+
  scale_color_discrete("")+
  geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE)
  , width=200, height=150,units='mm', dpi=300)

```


AIC for survival by individual
```{r}
glm1 <- glm(surv ~ ppt_winter*site, family = binomial, data = asmi.merged)
glm2 <- glm(surv ~ tmax_springSummer*ppt_winter*site, family = binomial, data = asmi.merged)
glm3 <- glm(surv ~ tmin_winter*ppt_winter*site, family = binomial, data = asmi.merged) 
glm4 <- glm(surv ~ ppt_fall*site, family = binomial, data = asmi.merged)
glm5 <- glm(surv ~ 1*site, family = binomial, data = asmi.merged)
glm6 <- glm(surv ~ ppt_springSummer*site, family = binomial, data = asmi.merged)
glm7 <- glm(surv ~ tmax_springSummer*site, family = binomial, data = asmi.merged) 
glm8 <- glm(surv ~ tmin_winter*site, family = binomial, data = asmi.merged)
glm.list <- list(glm1,glm2,glm3,glm4,glm5,glm6,glm7,glm8)
glm.names <- as.character(unlist(lapply(glm.list,formula)))
(glm.results <- aictab(glm.list, modnames=glm.names))
for(i in 2:length(glm.list)){
  print(exp(0.5*glm.results$Delta_AICc[i]))
}
```

```{r}
Fig4Survabiotic <- asmi.merged %>%
  ungroup() %>% ## but it's not grouped, maybe was taking as each row is a group without this call?
  dplyr::mutate(across(ppt_fall:tmin_winter, .fns = scale)) %>% 
  dplyr::mutate(ppt_winter_bin = cut(ppt_winter, breaks = 3)) %>%
ggplot(  aes(tmax_springSummer,surv,color = site))+
  geom_point()+
  theme_bw()+
  facet_grid(~ppt_winter_bin, scales = "free", 
             labeller = labeller(ppt_winter_bin =
                                   c("(-1.86,-0.395]" = "low winter precipitation", 
                                     "(-0.395,1.07]" = "mid winter precipitation",
                                     "(1.07,2.53]" = "high winter precipitation"))
             )+
  xlab("Summer maximum temperature")+
  ylab("Survival")+
  geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE)+
  ggtitle("b)")
```



Table 3e
#AIC for reproduction per plot   
ps.asmi.reduced are plot summaries
```{r}

## Fruit and reproduction by above ground growth - correlated
ps.asmi.reduced %>%
  mutate(FlYN = case_when(Total.Fruit >0 ~ 1, Total.Fruit == 0 ~ 0)) %>%
ggplot(  aes(Total.Alive, FlYN))+
  geom_point()+
  facet_wrap(~Site, scales = "free_x")+
  xlab("AGG")+
  ylab("Fruit")+
  theme_bw()+
  geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE)

asmi.reproductive <- 
  ps.asmi.reduced %>%
  mutate(site = case_when(Site == 1 ~ "Cebolla Mid",
                          Site == 2 ~ "Cebolla North",
                          Site == 5 ~ "Site 5",
                          Site == 15 ~ "Site 15",
                          Site == 19 ~ "Site 19",
                          Site == 26 ~ "Site 26")) %>%
  left_join(asmi.season.wide,  by = c("site" = "site",
                                      "Plot" = "Plot",
                                      "Year" = "Prev12")) %>%
  mutate(FlYN = case_when(Total.Fruit > 0 ~ 1, Total.Fruit == 0 ~ 0)) %>%
  ungroup() %>% ## but it's not grouped, maybe was taking as each row is a group without this call?
  dplyr::mutate(across(ppt_fall:tmin_winter, .fns = scale)) 

#Candidate models  
glm1 <- glm(FlYN ~ ppt_winter*site, family = binomial, data = asmi.reproductive)
glm2 <- glm(FlYN ~ tmax_springSummer*ppt_winter*site, family = binomial, data = asmi.reproductive)
glm3 <- glm(FlYN ~ tmin_winter*ppt_winter*site, family = binomial, data = asmi.reproductive) 
glm4 <- glm(FlYN ~ ppt_fall*site, family = binomial, data = asmi.reproductive)
glm5 <- glm(FlYN ~ 1*site, family = binomial, data = asmi.reproductive)
glm6 <- glm(FlYN ~ ppt_springSummer*site, family = binomial, data = asmi.reproductive)
glm7 <- glm(FlYN ~ tmax_springSummer*site, family = binomial, data = asmi.reproductive) 
glm8 <- glm(FlYN ~ tmin_winter*site, family = binomial, data = asmi.reproductive)
glm.list <- list(glm1,glm2,glm3,glm4,glm5,glm6,glm7,glm8)
glm.names <- as.character(unlist(lapply(glm.list,formula)))
(glm.results <- aictab(glm.list, modnames=glm.names))
for(i in 2:length(glm.list)){
  print(exp(0.5*glm.results$Delta_AICc[i]))
}
```

```{r}
## Figure 4b reproduction or none
Fig4bReprodYN <- asmi.reproductive %>%
  dplyr::mutate(ppt_winter_bin = cut(ppt_winter, breaks = 3)) %>%
ggplot(  aes(tmax_springSummer,FlYN))+
  geom_point()+
  theme_bw()+
  facet_grid(~ppt_winter_bin, scales = "free")+
  xlab("Summer maximum temperature")+
  ylab("Fruit production by plot")+
  geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE)

Fig4bReprodYN_site <- asmi.reproductive %>%
  dplyr::mutate(ppt_winter_bin = cut(ppt_winter, breaks = 3)) %>%
ggplot(  aes(tmax_springSummer,FlYN, colour=site))+
  geom_point()+
  theme_bw()+
  facet_wrap(~ppt_winter_bin, scales = "free")+
  xlab("Summer maximum temperature")+
  ylab("Fruit production by plot")+
  geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE, alpha = 0.1)+
  ggtitle("c)")

```

# AIC for fruit  
```{r}
## pull out when no reproduction, that was the binomial parts, just do the amount when there is reproduction
asmi.fruit <- asmi.reproductive %>%
  filter(Total.Fruit > 0)

glm1 <- glm(Total.Fruit ~ ppt_winter*site, family = poisson(link = 'log'), data = asmi.fruit)
glm2 <- glm(Total.Fruit ~ tmax_springSummer*ppt_winter*site, family = poisson(link = 'log'), data = asmi.fruit)
glm3 <- glm(Total.Fruit ~ tmin_winter*ppt_winter*site, family = poisson(link = 'log'), data = asmi.fruit) 
glm4 <- glm(Total.Fruit ~ ppt_fall*site, family = poisson(link = 'log'), data = asmi.fruit)
glm5 <- glm(Total.Fruit ~ 1*site, family = poisson(link = 'log'), data = asmi.fruit)
glm6 <- glm(Total.Fruit ~ ppt_springSummer*site, family = poisson(link = 'log'), data = asmi.fruit)
glm7 <- glm(Total.Fruit ~ tmax_springSummer*site, family = poisson(link = 'log'), data = asmi.fruit) 
glm8 <- glm(Total.Fruit ~ tmin_winter*site, family = poisson(link = 'log'), data = asmi.fruit)
glm.list <- list(glm1,glm2,glm3,glm4,glm5,glm6,glm7,glm8)
glm.names <- as.character(unlist(lapply(glm.list,formula)))
(glm.results <- aictab(glm.list, modnames=glm.names))
for(i in 2:length(glm.list)){
  print(exp(0.5*glm.results$Delta_AICc[i]))
}
```

```{r}
Fig4Fruit <- asmi.fruit %>%
  dplyr::mutate(ppt_winter_bin = cut(ppt_winter, breaks = 3)) %>%
  dplyr::mutate(tmax_springSummer_bin = cut(tmax_springSummer, breaks = 3)) %>%
ggplot(  aes(tmax_springSummer_bin,log(Total.Fruit), color = site))+
  geom_point()+
  theme_bw()+
  geom_boxplot()+
  facet_grid(~ppt_winter_bin, scales = "free")+
  xlab("low, mid, and high summer maximum temperature")+
  ylab("log(Total fruit production)")+
  scale_color_discrete("Site")+
  ggtitle("d) low, mid, and high winter precipitation")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) # rotate labels
```

 
#AIC for reproductive
Table 3c and d
probability of reproduction per individual
```{r}

# X..Flowered is %; X..Flowered.1 is count of yes
head(asmi.raw)

asmi.raw$Creek <- "SouthBeaver"
asmi.raw$Creek[asmi.raw$AsMi_site_id < 3] <- "Cebolla" 
asmi.raw$Creek <- as.factor(asmi.raw$Creek)

# asmi.raw$flower is yes/no for reproduction
m1 <- glm(flower ~ year, family=binomial(link=logit), data = asmi.raw)
summary(m1)

#Candidate models  
m2 <- glm(flower ~ year*as.factor(AsMi_site_id), family = binomial(link = 'logit'), data = asmi.raw)
m3 <- glm(flower ~ year*Creek, family = binomial(link = 'logit'), data = asmi.raw) #Need add creek!
m4 <- glm(flower ~ year*fence, family = binomial(link = 'logit'), data = asmi.raw)
m5 <- glm(flower ~ 1, family = binomial(link = 'logit'), data = asmi.raw)
m6 <- glm(flower ~ as.factor(AsMi_site_id), family = binomial(link = 'logit'), data = asmi.raw)
m7 <- glm(flower ~ Creek, family = binomial(link = 'logit'), data = asmi.raw) 
m8 <- glm(flower ~ fence, family = binomial(link = 'logit'), data = asmi.raw)

m.list <- list(m1,m2,m3,m4,m5,m6,m7,m8)
m.names <- as.character(unlist(lapply(m.list,formula)))
(m.results <- aictab(m.list, modnames=m.names))

#evidence ratio 
for(i in 2:length(m.list)){
  print(exp(0.5*m.results$Delta_AICc[i]))
}
```



Table 5: Average Astragalus microcymbus fruit per plot within the South Beaver Creek Drainage near Gunnison, CO and Cebolla Creek drainage. Site 1 is Cebolla Creek Mid and site 2 is Cebolla Creek North. Standard errors are given in parentheses. 
```{r}
fruit <- aggregate(fruit ~ AsMi_plot_id + year + AsMi_site_id + fence, 
                  data = asmi.raw, function(x) sum(x,na.rm = TRUE))
head(fruit)


tbl3.1 <- summarySE(fruit, measurevar="fruit",groupvars=c("AsMi_site_id","year"))

sites <- unique(tbl3.1$AsMi_site_id)
tbl3 <- lapply(sites, function(x){
  paste(round(tbl3.1[tbl3.1$AsMi_site_id == x,"fruit"],2)," (",
        round(tbl3.1[tbl3.1$AsMi_site_id == x,"se"],1), ")", sep="")
})

#Cebolla Creek
write.csv(data.frame(tbl3[[1]],tbl3[[2]]), file=paste(savepath,"Table5_Cebolla.csv"), row.names=TRUE)
#South Beaver Creek
write.csv(data.frame(tbl3[[3]],tbl3[[4]],tbl3[[5]],tbl3[[6]]), file=paste(savepath,"Table5_SouthBeaver.csv"), row.names=TRUE)

```


################### Stage-based PVA start ##############################
#Table 6: Growth rate (λ) and standard deviation within treatment (fenced or open plots) of Astragalus microcymbus individuals within the South Beaver Creek drainage near Gunnison, CO. Plot 598 in site 26, added in 2004, is excluded.   

### But if I add individuals not as seedlings (even though I know they aren't seedlings this year) then they aren't given credit for reproducing.. # could add a New2me category that is clearly not a seedling but a delayed/missed one. Then should add a seedling to the previous year as a stop gap? So count up number of seedlings and number of seedlings in the next year that are reproductive and subtract them from the current seedling number!
```{r}
table(asmi.raw$year,asmi.raw$AsMi_plot_id)
table(asmi.raw$browsing)
table(asmi.raw$Browsing...Status) 
nrow(asmi.raw) #13806->16377->17817->19324
table(asmi.raw$AsMi_site_id,asmi.raw$year)

cebolla <- asmi.raw[asmi.raw$AsMi_site_id %in% c(1,2),]
table(cebolla$AsMi_site_id,cebolla$year)

sbc <- asmi.raw[asmi.raw$AsMi_site_id %in% c(5,15,19,26),]
table(sbc$AsMi_site_id,sbc$year)

#remove plot 598 from SBC, it was added late; Plot 598 was added in 2004, remove for this. .. or do all plots on their own instead of by sites? Or make sure the transitions are proportional, I think I need each plot on it's own since they start at different times, can't combine into one site. 
# or since they aren't seedlings the first year, it's fine, there's still the number transitioning 
# sbc <- sbc[sbc$AsMi_plot_id != 598,]

# the others added later: 238 & 300 @ 1996 - take out 1995
# sbc <- sbc[sbc$year > 1995,]

# KEY TO OBJECTS
# After commenting out the removed year and the added plots... then asmi.1 is SBC, cebolla is Cebolla and asmi.all is both
asmi.1 <- sbc[order(sbc$AsMi_site_id, sbc$AsMi_tag_id, sbc$year),]
cebolla <- cebolla[order(cebolla$AsMi_site_id, cebolla$AsMi_tag_id, cebolla$year),]

asmi.1$status <- factor(asmi.1$status)
table(asmi.1$status)

cebolla$status <- factor(cebolla$status)
table(cebolla$status)

#just keep all together go by plot
asmi.all <- asmi.raw[order(asmi.raw$AsMi_site_id, 
                           asmi.raw$AsMi_tag_id, asmi.raw$year),]
table(asmi.all$status)

```


## Stage-based PVA prep and running

Set order of classes
```{r}
# Later work in seeds
# stages <- c("seed", "seedling", "vegetative", "reproductive", "dormant","dead") 

stages <- c("seedling", "vegetative", "reproductive", "dormant","dead") 

# SBC
# Cebolla
asmi.1$status <- ordered(asmi.1$status, levels = stages)
cebolla$status <- ordered(cebolla$status, levels = stages)

# Both
asmi.all$status <- ordered(asmi.all$status, levels = stages)

```

check errors
```{r}
table(asmi.1$status)
table(cebolla$status)

# should all be reproductive (status 4 in DBG phpMyAdmin)
asmi.1[asmi.1$flower == 1 & asmi.1$status == "vegetative",]
cebolla[cebolla$flower == 1 & cebolla$status == "vegetative",]
asmi.all[asmi.all$flower == 1 & asmi.all$status == "vegetative",]

# made all NA lengths 0
# table(asmi.1$status[is.na(asmi.1$length)])

asmi.1$browsed[asmi.1$browsing==0]<-FALSE  	
asmi.1$browsed[asmi.1$browsing==1]<-TRUE
table(asmi.1$browsed)
table(asmi.1$browsing)

# Same for cebolla plots
cebolla$browsed[cebolla$browsing==0]<-FALSE    
cebolla$browsed[cebolla$browsing==1]<-TRUE
table(cebolla$browsed)
table(cebolla$browsing)


asmi.all$browsed[asmi.all$browsing==0]<-FALSE  	
asmi.all$browsed[asmi.all$browsing==1]<-TRUE
table(asmi.all$browsed)
table(asmi.all$browsing)
```


### Make 'seedlings' that are reprodutive 'reproductive' before binding stage - fate  
Merge year to year, year.x is year t, year.y is year t+1   
remove dead from stages, just fate    
At this point, just get asmi.all1 to work, if can deal with addition of plots, then can put the two together
```{r}
# first use seasonal observation percentages, climate, and size the next time seen to turn all dormant (or not yet germinated for seedlings with length > 10cm) to seedling, vegetative, or reproductive 
# percent of dormant that were each of the following in July
# perstagedormant <- c(Year = 2014:2015, seedling = c())
## how many individuals that are dormant in July in 2014 and 2015 were of each category within the year?  
head(asmi.all)

# clearly not 'seedlings' just missed them. can make StagePVA add any 'seedlings' and any new tags
asmi.all$status[asmi.all$status == "seedling" & asmi.all$flower == 1] <- "reproductive"
# 'seedlings' that are large should be called vegetative (will be added accordingly as recruitment from reproductive two years prior)
hist(asmi.all$length[asmi.all$status == "seedling"])
ggplot(asmi.all, aes(status, length))+
  geom_violin(scale = "width")

asmi.all1 <- subset(merge(asmi.all, asmi.all, by = "AsMi_tag_id", sort = FALSE), year.x == year.y - 1)  

# Which of these say dead to seedling, should get rid of these, or dead to dead
# asmi.all1[asmi.all1$status.x=="dead",]
# asmi.all1 <- asmi.all1[asmi.all1$status.x!="dead",]
```


    
Want    
Narrow down to      
[1] "AsMi_site_id.x" "AsMi_tag_id"    "year.x"             
[4] "length.x"       "fruit.x"        "browsed.x"           
[7] "fence.x"        "status.x"       "status.y"     
```{r}
cols <- c("AsMi_site_id.x","AsMi_tag_id","year.x","length.x",
          "fruit.x","browsed.x","fence.x","status.x","status.y","AsMi_plot_id.x", "length.y")
asmi.all2 <- asmi.all1[, names(asmi.all1) %in% unique(grep(paste(cols,collapse="|"),
                                                  names(asmi.all1), value = TRUE))] # T/F so in the order of data frame
colnames(asmi.all2) <- c( "tag","year","length","fruits","stage","plot",
                       "site","fenced","browse","length1","fate")

## re-number
rownames(asmi.all2) <- 1:nrow(asmi.all2)

# Get rid of stage 'dead' because nothing starts as dead!
asmi.all2$stage <- ordered(asmi.all2$stage, levels = stages[-length(stages)])

# check transitions
#fate down and stage across the top; These are the raw numbers combined for all years 
table(Fate = asmi.all2$fate, Stage = asmi.all2$stage) #Nope, cannot have 2 seedlings stay seedlings! And Dormant never go dead!

asmi.all2[asmi.all2$fate == "seedling" & asmi.all2$stage == "seedling",] # tag 3571 and 3946
# asmi.raw[asmi.raw$AsMi_tag_id %in% c(3571,3946),]

asmi.all2[asmi.all2$stage == "dormant" & asmi.all2$fate == "dead",]

```

bootstrap distributions of population growth rates (lambda), stage vectors, and projection matrix elements by randomly sampling with replacement from a stage-fate data frame of observed transitions   

Doesn't make sense... shouldn't be so high... Because 26 had additional plots added in 1996?    
There are seedlings that go from 'seedling' to 'dead' that have values for $seedling   
something is off.    
Made some fixes to raw data where fruit were counted but confusion led to putting 0 for flower column    
Will change all seedling with fruit to reproductive

```{r}
asmi.boot <- asmi.all2
asmi.boot$fruits[is.na(asmi.boot$fruits)] <- 0

table(asmi.boot$year, asmi.boot$site) # from 1995 transitions stage -> fate up to currentyr-1 stage->fate 
# add 'seedling' column
# give credit for reproductive seedlings to two years prior because must be more than one year old
asmi.boot[asmi.boot$fruits>0 & asmi.boot$stage=="seedling" & asmi.boot$length<20,]
# should probably not call plants over 20cm with fruit a seedling
asmi.boot$stage[asmi.boot$fruits>0 & asmi.boot$stage=="seedling" & asmi.boot$length>19] <- "reproductive"


nrow(asmi.boot ) #13868 -> 15280

asmi.boot$seedling <- unlist(lapply(split(asmi.boot, asmi.boot$plot), function(plot){
  # [-length(sort(unique(plot$year)))] want all years to get correct length
  out <- lapply(sort(unique(plot$year)),function(year){
  # For each next year, how many seedlings were there? 
  seedlings.t1 <- nrow(asmi.boot[asmi.boot$year == year+1 &
                                   asmi.boot$stage == "seedling" & 
                                   asmi.boot$fruits==0,])
  seedlings.t2 <- nrow(asmi.boot[asmi.boot$year == year+2 & 
                                   asmi.boot$stage == "seedling" & 
                                   asmi.boot$fruits>0,])
  seedlings <- sum(seedlings.t1, seedlings.t2)
  # The number of fruit produced per individual divided by all fruit produced * seedlings in the next year
  seedlingsout <- plot$fruits[plot$year==year]/sum(plot$fruits[plot$year==year],na.rm = TRUE) * seedlings
  seedlingsout
  })
  out
}))

boottrans <- lapply(split(asmi.boot, asmi.boot$plot), function(x){
  data.frame(Plot = unique(x$plot),
             Site = unique(x$site),
             Boot = boot.transitions(x,1000,fertility = "fruits")$lambda)
  })

bt <- do.call(rbind, boottrans)

ggplot(bt, aes(as.factor(Plot), Boot, colour = as.factor(Plot)))+
  geom_boxplot()+
  facet_wrap(~Site, ncol=3, scales = "free")+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```



# Stage-based PVA
# From previous versions
cebolla <- asmi.raw[asmi.raw$AsMi_site_id %in% c(1,2),]
sbc <- asmi.raw[asmi.raw$AsMi_site_id %in% c(5,15,19,26),]

asmi.1 <- sbc[order(sbc$AsMi_site_id, sbc$AsMi_tag_id, sbc$year),]
cebolla <- cebolla[order(cebolla$AsMi_site_id, cebolla$AsMi_tag_id, cebolla$year),]

asmi.2 <- subset(merge(asmi.1, asmi.1, by = "AsMi_tag_id", sort = FALSE), year.x == year.y - 1)   
cebolla1 <- subset(merge(cebolla, cebolla, by = "AsMi_tag_id", sort = FALSE), year.x == year.y - 1)  

# Because it adds a slot for 1995 - currentYr
Why are there 25 slots for Site PVA? and all but the last four are empty - last 4 have the 4 SBC populations
notfenced has 21 blank (each year)

Dormancy can be set to 0-1  

## in 2021 to do: use the intra-annual visits to create model of climate and probability of stage when dormant in July 

```{r}
# In 2020 all the tags were removed by someone. An attempt was made to relocate and retag plants but that was abandoned. Need to remove all 2020 data and after. 
table(asmi.all2$stage[asmi.all2$plot == 89], asmi.all2$year[asmi.all2$plot==89])

asmi.all2[asmi.all2$plot == 799 & asmi.all2$year == 2012,]
asmi.all2[asmi.all2$plot == 799 & asmi.all2$year == 2020,]

# Test StagePVA_single
# df <- split(asmi.all2, asmi.all2$plot)[[1]]
# i <- unique(df$year)[1]
#     # t1 <- 1:7
#     # t2 <- 4:10
#     # setdiff(t2, t1) # new in t2 that weren't in t1
# rm(df);rm(i)

all.pva <- lapply(split(asmi.all2, asmi.all2$plot), function(df){
  out <- StagePVA_single(df)
  out
})

```

Discount sampling variability by estimating annual vital rates with generalized linear mixed model, lmer   
errors binomially distributed, use numbers of trials and successess for each year   
fit model with an intercept and random effect of year
## $\mu = sum(x*p)$ 
```{r, eval=FALSE}  
# Survival are the diagonal and below diagonal
  # x <- all.pva[[1]][[1]] # testing
vitalrates <- lapply(all.pva, function(m){
  years <- names(m)
  out <- do.call(rbind,lapply(m, function(x){
    # vital.gr <- sum(x[lower.tri(x)])
    # vital.stasis <- sum(diag(x))
    # vital.retro <- sum(x[upper.tri(x)][-3]) # But this says that dormant to other is retrogressive and is not really true
    # vital.repro <- sum(x[1,])
    long <- as.data.frame(x)
    wide <- long$Freq
    names(wide) <- paste(long$Var2,long$Var1, sep="-")
    wide
    # data.frame(transition = paste(long$Var1,long$Var2, sep="-"), Rate = long$Freq)
    # data.frame(growth = vital.gr, statis = vital.stasis, retrog = vital.retro, reprod = vital.repro)
  }))
  data.frame(out, year = years)
  })

vitalrates_all <- do.call(rbind, lapply(1:length(vitalrates), function(i) data.frame(vitalrates[[i]], Plot = names(vitalrates)[i])))


## want the number of each for each year, not the rates. 
## want maximum likelihood of the survival given the data - joint likelihood of each data point
log_likelihood <- function(par_p, par_N, data){
  LL <- sum(dbinom(x = data, prob = par_p, size = par_N, log=TRUE))
  LL
}


## not counts but the percent survival 
df1 <- split(asmi.all2, list(asmi.all2$plot), drop = TRUE)[[1]] # , asmi.all2$year
df <- split(df1, list(df1$year))[[1]]
  n_t <- length(df$stage[df$stage != "dead"]) 
  n_stage <- colSums(table(df$fate, df$stage))
  n_surv <- colSums(table(df$fate, df$stage)[-5,])
  loglike <- dbinom(n_surv[1], size = n_stage[1], prob = seq(0.01,0.99, by=0.01))
plot(seq(0.01,0.99, by=0.01), loglike, type="l")
  points(seq(0.01,0.99,by=0.01)[which(loglike == max(loglike))],0, col=2)
  
  data <- data.frame(x = n_surv[1], p = P_s, xp = n_surv[1]*P_s, x2p = n_surv[1]^2 * P_s)
  # mu = np   (n = number of trials; p = probability of success)
  # variance (i.e. sigma squared) = n*p*(1-p)
  # SD = sqrt(n*p*(1-p))
  
asmi.counts <- do.call(rbind,lapply(split(asmi.all2, list(asmi.all2$plot), drop=TRUE), function(df1){
  timeseries <- do.call(rbind,lapply(split(df1, list(df1$year), drop=TRUE), function(df){
  n_t <- length(df$stage[df$stage != "dead"]) 
  n_stage <- colSums(table(df$fate, df$stage))
  n_surv <- colSums(table(df$fate, df$stage)[-5,])
  survivalXstage <- do.call(rbind,lapply(1:3, function(i){
    if(n_stage[i]>0){
      loglike <- dbinom(n_surv[i], size = n_stage[i], prob = seq(0.01,0.99, by=0.01))
      P_s <- seq(0.01,0.99,by=0.01)[which(loglike == max(loglike))]
      var_p <- n_stage[i]*P_s*(1-P_s)
    } else {
        P_s <- NA 
        var_p <- NA
      }
    data.frame(stage = names(n_surv[i]), P_s = P_s, var_p = var_p, 
               Plot = unique(df$plot), Year = unique(df$year), Site = unique(df$site))
    }))
  survivalXstage
  }))
  timeseries
}))

ggplot(asmi.counts, aes(stage, P_s))+
  geom_boxplot()+
  # geom_point(position = position_jitterdodge())+
  # facet_wrap(~as.factor(Year))+
  theme_bw()+
  facet_wrap(~as.factor(Site))

p_ss <- asmi.counts$P_s[asmi.counts$stage=="reproductive" & !is.na(asmi.counts$P_s)]
hist(p_ss)
min(p_ss)
max(p_ss)
hist(log(p_ss/(1-p_ss))) ## This is not between 0 and 1!! but I did the logit

## sampling variability in annual vital rates
# glm1 <- glmer(seedling.vegetative ~ (1|year) + (1|Plot), family = binomial, data = vitalrates_all)
glm1 <- glmer(log(P_s/(1-P_s)) ~ 1 + (1|Plot) + (1|Year), family = binomial(link='logit'),
              data = asmi.counts[asmi.counts$stage=="reproductive" & !is.na(asmi.counts$P_s),])
glm2 <- glmer(P_s ~ 1 + (1|Year), family = binomial(link='logit'),
              data = asmi.counts[asmi.counts$stage=="reproductive",])

```




# Matrix Models     
## Table 5: Growth rate    
Pre, post, and all functions
```{r}
# all.pva is the list of plots which each is a list of years from StagePVA_single
# plots is a vector of plots to use

GrowthRateMeanSD <- function(all.pva = all.pva, plots, PreFence = FALSE, PostFence = FALSE){
  plotsout <- unlist(lapply(1:length(plots), function(i){
    oneplot <- all.pva[names(all.pva) %in% plots][[i]]
    if(PreFence == TRUE){
      oneplot <- oneplot[as.numeric(names(oneplot)) < 2005]
    }
    if(PostFence == TRUE){
      oneplot <- oneplot[as.numeric(names(oneplot)) >= 2005]
    }
    if(length(oneplot)>1){
      plotlambda <- lapply(1:length(oneplot), function(tm){
        popbio::lambda(oneplot[[tm]])
        })
    unlist(plotlambda)
    }
  }))
  
  # Table 5: Growth rate (lambda) and standard deviations Fenced Pre-fencing
  data.frame(mean(plotsout), sd(plotsout))
  }

# GrowthRateMeanSD(all.pva, plots = openSBCplots)

```

Table 5: Average growth rate ($\lambda$) and standard deviation ...   
```{r}

# South Beaver Creek
SBCplots <- unique(asmi.raw$AsMi_plot_id[asmi.raw$AsMi_site_id > 4])
GrowthRateMeanSD(all.pva, SBCplots, PreFence = TRUE)

all.pva['89'] # not first year or last year so 2015-2017 because 2019 was the last year and the year == y:y+1
all.pva['90']
all.pva['598'] # Yay! it goes 2005/06 through 2019/20 when current year is 2021


# Are only at SBC
fencedplots <- unique(asmi.raw$AsMi_plot_id[asmi.raw$fence == "y"])
GrowthRateMeanSD(all.pva, fencedplots, PreFence = TRUE)
GrowthRateMeanSD(all.pva, fencedplots, PostFence = TRUE)

# Open South Beaver Creek 
openSBCplots <- setdiff(SBCplots,fencedplots)
GrowthRateMeanSD(all.pva, openSBCplots, PreFence = TRUE)
GrowthRateMeanSD(all.pva, openSBCplots, PostFence = TRUE)
GrowthRateMeanSD(all.pva, openSBCplots)

# Site 05
site05all <-  unique(asmi.raw$AsMi_plot_id[asmi.raw$AsMi_site_id == 5])
fenced05 <- intersect(site05all, fencedplots)
open05 <- setdiff(site05all, fencedplots)
GrowthRateMeanSD(all.pva, site05all, PreFence = TRUE)
GrowthRateMeanSD(all.pva, fenced05, PreFence = TRUE)
GrowthRateMeanSD(all.pva, fenced05, PostFence = TRUE)
GrowthRateMeanSD(all.pva, open05, PreFence = TRUE)
GrowthRateMeanSD(all.pva, open05, PostFence = TRUE)
GrowthRateMeanSD(all.pva, open05)

# Site 15
site15all <-  unique(asmi.raw$AsMi_plot_id[asmi.raw$AsMi_site_id == 15])
GrowthRateMeanSD(all.pva, site15all, PreFence = TRUE)
GrowthRateMeanSD(all.pva, site15all, PostFence = TRUE)
GrowthRateMeanSD(all.pva, site15all)

# Site 19
site19all <-  unique(asmi.raw$AsMi_plot_id[asmi.raw$AsMi_site_id == 19])
fenced19 <- intersect(site19all, fencedplots)
open19 <- setdiff(site19all, fencedplots)
GrowthRateMeanSD(all.pva, site19all, PreFence = TRUE)
GrowthRateMeanSD(all.pva, fenced19, PreFence = TRUE)
GrowthRateMeanSD(all.pva, fenced19, PostFence = TRUE)
GrowthRateMeanSD(all.pva, open19, PreFence = TRUE)
GrowthRateMeanSD(all.pva, open19, PostFence = TRUE)
GrowthRateMeanSD(all.pva, open19)

# Site 26
site26all <-  unique(asmi.raw$AsMi_plot_id[asmi.raw$AsMi_site_id == 26])
fenced26 <- intersect(site26all, fencedplots)
open26 <- setdiff(site26all, fencedplots)
GrowthRateMeanSD(all.pva, site26all, PreFence = TRUE)
GrowthRateMeanSD(all.pva, fenced26, PreFence = TRUE)
GrowthRateMeanSD(all.pva, fenced26, PostFence = TRUE)
GrowthRateMeanSD(all.pva, open26, PreFence = TRUE)
GrowthRateMeanSD(all.pva, open26, PostFence = TRUE)
GrowthRateMeanSD(all.pva, open26)

#Cebolla Creek
cebolla <- unique(asmi.raw$AsMi_plot_id[asmi.raw$AsMi_site_id < 4])
site1 <- unique(asmi.raw$AsMi_plot_id[asmi.raw$AsMi_site_id == 1])
site2 <- unique(asmi.raw$AsMi_plot_id[asmi.raw$AsMi_site_id == 2])
GrowthRateMeanSD(all.pva, cebolla)
GrowthRateMeanSD(all.pva, site1)
GrowthRateMeanSD(all.pva, site2)

```

# Figure 4: Life cycle diagram of Astragalus microcymbus   
```{r}
# remove a level of list of lists with recursive = FALSE
(A <- mean(unlist(all.pva, recursive = FALSE)))
eigen.analysis(A)
```


```{r}
grViz("digraph integrated_pop {
      
      # digraph = directed, graph = undirected, graphID
      graph [compound = true, color = blue, rankdir = TB]
      
      # node definitions with substituted label text
      node [shape = circle, fontname = Helvetica]
      # Demographic monitoring
      a [label = '@@1-1'] # seedling
      b [label = '@@1-2'] # veg
      c [label = '@@1-3'] # rep
      d [label = '@@1-4'] # dormant
      
      # name must start with 'cluster_'
      subgraph cluster_demography {
        graph [style = dashed, color = Sienna]
      {rank = min; b}
      {rank = same; a;c}
      # {rank = min; b}
      {rank = max; d}
      # {rank = max; a;b;c}
        a -> b [label = '@@2-2']
        a -> c [label = '@@2-3']
        a -> d [label = '@@2-4']
        b -> b [label = '@@3-2']
        b -> c [label = '@@3-3']
        b -> d [label = '@@3-4']
        c -> d [label = '@@4-4']
        c -> a [style = dashed, color = LimeGreen, label = '@@4-1']
        c -> b [color = red, label = '@@4-2']
        c -> c [label = '@@4-3']
        d -> b [color = red, label = '@@5-2']
        d -> c [color = red, label = '@@5-3']
        d -> d [label = '@@5-4']
        
        label = 'Demography'
      }
      
      }
      
      [1]: c('Seedling','Vegetative','Reproductive','Dormant')
      [2]: round(A[,1],2) # seedling to
      [3]: round(A[,2],2) # veg to
      [4]: round(A[,3],2) # reprod to
      [5]: round(A[,4],2) # dormant to
      ")

## Export to save as impage 
```




Skip:
```{r, eval=FALSE}
## Testing to make the function above
# str(all.pva)
# names(all.pva)
# '%ni%' <- Negate('%in%')
 
 
# Are only at SBC
fencedplots <- unique(asmi.raw$AsMi_plot_id[asmi.raw$fence == "y"])
fencedplotmeans <- lapply(1:length(fencedplots), function(i){
  mean(all.pva[names(all.pva) %in% fencedplots][[i]])
  })


# Pre-fencing t+1 of start of plot (earliest is 1996) - 2005 where t+1 == 2005, transition matrix is called 2004
fencedplotlambdasPre <- unlist(lapply(1:length(fencedplots), function(i){
  fenced1 <- all.pva[names(all.pva) %in% fencedplots][[i]]
  prefence <- fenced1[as.numeric(names(fenced1)) < 2005]
  # postfence <- fenced1[as.numeric(names(fenced1)) >= 2005]
  prefencelambda <- lapply(1:length(prefence), function(tm){
    popbio::lambda(prefence[[tm]])
  })
  # postfencelambda <- lapply(1:length(postfence), function(tm){
  #   popbio::lambda(postfence[[tm]])
  # })
  # data.frame(PreFmean = mean(do.call(rbind,prefencelambda)), PreFSD = sd(do.call(rbind,prefencelambda)),
  #            PostFmean = mean(do.call(rbind,postfencelambda)), PostFSD = sd(do.call(rbind,postfencelambda)))
  do.call(rbind,prefencelambda)
  }))

# Table 5: Growth rate (lambda) and standard deviations Fenced Pre-fencing
mean(fencedplotlambdasPre); sd(fencedplotlambdasPre)

fencedplotlambdasPost <- unlist(lapply(1:length(fencedplots), function(i){
  fenced1 <- all.pva[names(all.pva) %in% fencedplots][[i]]
  postfence <- fenced1[as.numeric(names(fenced1)) >= 2005]
  postfencelambda <- lapply(1:length(postfence), function(tm){
    popbio::lambda(postfence[[tm]])
  })
  # do.call(rbind,postfencelambda)
  unlist(postfencelambda)
}))

# Table 5: Growth rate (lambda) and standard deviations Fenced Post-fencing
mean(fencedplotlambdasPost); sd(fencedplotlambdasPost)

# South Beaver Creek
SBCplots <- unique(asmi.raw$AsMi_plot_id[asmi.raw$AsMi_site_id > 4])  

SBCplotlambdasPre <- unlist(lapply(1:length(SBCplots), function(i){
  fenced1 <- all.pva[names(all.pva) %in% SBCplots][[i]]
  prefence <- fenced1[as.numeric(names(fenced1)) < 2005] # One was started in 2004 so won't have any
  if(length(prefence)>1){
    prefencelambda <- lapply(1:length(prefence), function(tm){
      popbio::lambda(prefence[[tm]])
      })
    }
  unlist(prefencelambda)
  }))

# Table 5: Growth rate (lambda) and standard deviations Open pre-fencing
mean(SBCplotlambdasPre); sd(SBCplotlambdasPre)

# Open South Beaver Creek 
openSBCplots <- setdiff(SBCplots,fencedplots)

OpenplotlambdasPre <- unlist(lapply(1:length(openSBCplots), function(i){
  fenced1 <- all.pva[names(all.pva) %in% openSBCplots][[i]]
  prefence <- fenced1[as.numeric(names(fenced1)) < 2005]
  if(length(prefence)>1){
    prefencelambda <- lapply(1:length(prefence), function(tm){
      popbio::lambda(prefence[[tm]])
      })
    }
  unlist(prefencelambda)
  }))

# Table 5: Growth rate (lambda) and standard deviations Open Pre-fencing
mean(OpenplotlambdasPre); sd(OpenplotlambdasPre)


OpenplotlambdasPost <- unlist(lapply(1:length(openSBCplots), function(i){
  fenced1 <- all.pva[names(all.pva) %in% openSBCplots][[i]]
  prefence <- fenced1[as.numeric(names(fenced1)) >= 2005]
  if(length(prefence)>1){
    prefencelambda <- lapply(1:length(prefence), function(tm){
      popbio::lambda(prefence[[tm]])
      })
    }
  unlist(prefencelambda)
  }))

# Table 5: Growth rate (lambda) and standard deviations Open Pre-fencing
mean(OpenplotlambdasPost); sd(OpenplotlambdasPost)

# Open SBC all years
Openplotlambdas <- unlist(lapply(1:length(openSBCplots), function(i){
  fenced1 <- all.pva[names(all.pva) %in% openSBCplots][[i]]
  prefencelambda <- lapply(1:length(fenced1), function(tm){
      popbio::lambda(fenced1[[tm]])
      })
  unlist(prefencelambda)
  }))

# Table 5: Growth rate (lambda) and standard deviations Open Pre-fencing
mean(Openplotlambdas); sd(Openplotlambdas)


```







### OLD, skip
```{r, eval=FALSE}
lmdSD(asmi.pva$pro.matrix, 1996, currentyr-2)
#         lmda        SD
# [1,] 1.179791 0.9690063

#Pre-fencing (2004-2005 transition)
paste(round(lmdSD(asmi.pva$pro.matrix, 1996, 2004)[1],2)," (",
      round(lmdSD(asmi.pva$pro.matrix, 1996, 2004)[2],2), ")", sep ="")

mats.list <- list(asmi.pva$pro.matrix,asmi.pva$fenced.pro.matrix,asmi.pva$notfenced.pro.matrix)
tbl4.all <- sapply(mats.list, function(x){
   paste(round(lmdSD(x, 1996, 2004)[1],2)," (",
         round(lmdSD(x, 1996, 2004)[2],2),")", sep="")
    })

t(tbl4.all)

# Post-fencing (2005-year before current so currentyr-2:currentyr-1)
tbl4.allpost <- sapply(mats.list[-1], function(x){
  paste(round(lmdSD(x, 2005,currentyr-2)[1],2)," (",
        round(lmdSD(x, 2005,currentyr-2)[2],2),")", sep="")
})

write.csv(tbl4.allpost, file=paste(savepath,"Table4_allSBCpost.csv"), row.names=TRUE)


tbl4.allopen <- paste(round(lmdSD(asmi.pva$notfenced.pro.matrix, 1996,currentyr-2)[1],2)," (",
                      round(lmdSD(asmi.pva$notfenced.pro.matrix, 1996,currentyr-2)[2],2),")", sep="")


write.csv(tbl4.allopen, file=paste(savepath,"tbl4_allSBCopen.csv"), row.names=TRUE)
```

Cebolla all
1:Mid
2:North
```{r, eval=FALSE}

# All
lmdSD(cebolla.pva$pro.matrix, 2014, currentyr-2)
# lmdSD(cebolla.pva$pro.matrix, 2014, currentyr-1) #in 2016, not enough data to exclude the last one
#         lmda       SD
#[1,] 1.138889 1.038878
#[1,] 1.318087 0.6141668  in 2019

#Cebolla Mid = Site 1
paste(round(lmdSD(cebolla.pva$Site$`1`, 2014, currentyr-2)[1],2)," (",
      round(lmdSD(cebolla.pva$Site$`1`, 2014, currentyr-2)[2],2), ")", sep ="")

#Cebolla North = Site 2
paste(round(lmdSD(cebolla.pva$Site$`2`, 2014, currentyr-2)[1],2)," (",
      round(lmdSD(cebolla.pva$Site$`2`, 2014, currentyr-2)[2],2), ")", sep ="")

mats.list <- list(cebolla.pva$pro.matrix,cebolla.pva$fenced.pro.matrix,cebolla.pva$notfenced.pro.matrix)
sapply(mats.list, function(x){
   paste(round(lmdSD(x, 2014, currentyr-2)[1],2)," (",
         round(lmdSD(x, 2014, currentyr-2)[2],2),")", sep="")
    })
```
 
T-test fenced vs. open after fencing installed   
```{r T.test paired growth rates, eval=FALSE}
t.test(lmdAn(asmi.pva$fenced.pro.matrix, 2005, currentyr-2),
       lmdAn(asmi.pva$notfenced.pro.matrix, 2005, currentyr-2),
       paired = TRUE)

```

T-test for growth rate before and after fencing  
```{r, eval=FALSE}
t.test(lmdAn(asmi.pva$fenced.pro.matrix, 1996, 2004),
       lmdAn(asmi.pva$fenced.pro.matrix, 2005, currentyr-2))
```


# Table 5: Growth rate (lambda) and standard deviation
pattern is:          

All pre-fence  1996-2004        |All post-fence 2005-currentyr-2 |Open plots 1996-currentyr-2   
--------------------------------|--------------------------------|----------------------    
asmi.pva$pro.matrix             |                                |  
asmi.pva$fenced.pro.matrix      | asmi.pva$fenced.pro.matrix     |           
asmi.pva$notfenced.pro.matrix   | asmi.pva$notfenced.pro.matrix  | asmi.pva$notfenced         
      
      
Sites 5,19,26,  1996-2004       
(which is through 2005 but starting transition of 2004)   

1996-2005               |   2005-2014            |   1996-2014
------------------------|------------------------|---------------------          
asmi.pva$Site$"5"       |                        |       
asmi.pva$fenced$"5"     | asmi.pva$fenced$"5"    |                
asmi.pva$notfenced$"5"  | asmi.pva$notfenced$"5" |  asmi.pva$notfenced$"5"             

Site 15
`asmi.pva$Site$"15"` ...        

[[1]]:All; [[2]]:fenced; [[3]]:open
```{r, eval=FALSE}
# matord.list <- list(asmi.pva$Site, asmi.pva$fenced,asmi.pva$notfenced)
matord.list <- list(all.pva$Site, all.pva$fenced,all.pva$notfenced)

# 1996 (remove first year) through 2004 since it's 2004-2005 before fencing
# All
# was asmi.2 instead of all.pva; still not working
tbl4.96.04 <- 
  lapply(as.character(unique(asmi.all$AsMi_site_id)), function(x){
    # mat <- cat("matord.list[[1]]$\`",x,"`", sep='')
    mat <- matord.list[[1]]$x
    outapply<-lapply(mat, function(y){
      out<- paste(round(lmdSD(y[[factor(x)]],1996,2004)[1],2)," (",
            round(lmdSD(y[[factor(x)]],1996,2004)[2],2),")", sep="")
      out
    })
    outapply
  })

#site 5
paste(round(lmdSD(asmi.pva$Site$'5',1996,2004)[1],2)," (",
            round(lmdSD(asmi.pva$Site$'5',1996,2004)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$fenced$'5',1996,2004)[1],2)," (",
            round(lmdSD(asmi.pva$fenced$'5',1996,2004)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$notfenced$'5',1996,2004)[1],2)," (",
            round(lmdSD(asmi.pva$notfenced$'5',1996,2004)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$fenced$'5',2005,currentyr-2)[1],2)," (",
            round(lmdSD(asmi.pva$fenced$'5',2005,currentyr-2)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$notfenced$'5',2005,currentyr-2)[1],2)," (",
            round(lmdSD(asmi.pva$notfenced$'5',2005,currentyr-2)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$notfenced$'5',1996,currentyr-2)[1],2)," (",
            round(lmdSD(asmi.pva$notfenced$'5',1996,currentyr-2)[2],2),")", sep="")

#Site 15
paste(round(lmdSD(asmi.pva$Site$'15',1996,2004)[1],2)," (",
            round(lmdSD(asmi.pva$Site$'15',1996,2004)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$Site$'15',2005,currentyr-2)[1],2)," (",
            round(lmdSD(asmi.pva$Site$'15',2005,currentyr-2)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$Site$'15',1996,currentyr-2)[1],2)," (",
            round(lmdSD(asmi.pva$Site$'15',1996,currentyr-2)[2],2),")", sep="")

#site 19
paste(round(lmdSD(asmi.pva$Site$'19',1996,2004)[1],2)," (",
            round(lmdSD(asmi.pva$Site$'19',1996,2004)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$fenced$'19',1996,2004)[1],2)," (",
            round(lmdSD(asmi.pva$fenced$'19',1996,2004)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$notfenced$'19',1996,2004)[1],2)," (",
            round(lmdSD(asmi.pva$notfenced$'19',1996,2004)[2],2),")", sep="")


paste(round(lmdSD(asmi.pva$fenced$'19',2005,currentyr-2)[1],2)," (",
            round(lmdSD(asmi.pva$fenced$'19',2005,currentyr-2)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$notfenced$'19',2005,currentyr-2)[1],2)," (",
            round(lmdSD(asmi.pva$notfenced$'19',2005,currentyr-2)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$notfenced$'19',1996,currentyr-2)[1],2)," (",
            round(lmdSD(asmi.pva$notfenced$'19',1996,currentyr-2)[2],2),")", sep="")

#site 26
paste(round(lmdSD(asmi.pva$Site$'26',1996,2004)[1],2)," (",
            round(lmdSD(asmi.pva$Site$'26',1996,2004)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$fenced$'26',1996,2004)[1],2)," (",
            round(lmdSD(asmi.pva$fenced$'26',1996,2004)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$notfenced$'26',1996,2004)[1],2)," (",
            round(lmdSD(asmi.pva$notfenced$'26',1996,2004)[2],2),")", sep="")


paste(round(lmdSD(asmi.pva$fenced$'26',2005,currentyr-2)[1],2)," (",
            round(lmdSD(asmi.pva$fenced$'26',2005,currentyr-2)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$notfenced$'26',2005,currentyr-2)[1],2)," (",
            round(lmdSD(asmi.pva$notfenced$'26',2005,currentyr-2)[2],2),")", sep="")

paste(round(lmdSD(asmi.pva$notfenced$'26',1996,currentyr-2)[1],2)," (",
            round(lmdSD(asmi.pva$notfenced$'26',1996,currentyr-2)[2],2),")", sep="")

#Cebolla North 1; Mid 2
paste(round(lmdSD(cebolla.pva$notfenced$'1',2014,currentyr-2)[1],2)," (",
            round(lmdSD(cebolla.pva$notfenced$'1',2014,currentyr-2)[2],2),")", sep="")

paste(round(lmdSD(cebolla.pva$notfenced$'2',2014,currentyr-2)[1],2)," (",
            round(lmdSD(cebolla.pva$notfenced$'2',2014,currentyr-2)[2],2),")", sep="")

```

Figure 3: Life cycle diagram of Astragalus microcymbus, 1996-currentyr-1 mean transition rates (solid lines) and fecundity rates (dashed lines), and resulting sensitivities and elasticities. Individuals that become reproductive in the first year are classified as seedlings. 

```{r, eval=FALSE}
# SBC and Cebolla
eigen.analysis(mean(all.pva$notfenced.pro.matrix))
mean(all.pva$notfenced.pro.matrix)

# Only SBC
eigen.analysis(mean(asmi.pva$notfenced.pro.matrix))
mean(asmi.pva$notfenced.pro.matrix)

```





#PCA what split mast seeding years, high domrant individuals (not AGG), and percent reproductive     


2013 report: winter temp, spring/summer temp - both PCs, all split   
2014 report: winter precip, fall precip, spring/summer precip - both PCs, all split     
2015 report: PC1: fall precip, winter min temp, spring/summer precip    
             PC2: fall min, fall max, winter precip - mast seeding    
2016 report: PC1: fall max temp, spring/summer min temp - nothing split   
             PC2: fall min temp, fall precip, winter precip winter max temp    
2017 report: PC1: fall min fall max    
             PC2: fall precip, winter precip   nobody separated   
             

Seasons    
Winter: December-March (12-3)    
Spring/summer: April-July (4-7)    
Fall: August-November (8-11)   


###########################################################################################################
Figure 3: Astragalus microcymbus individuals by fenced (open circle, y)
 Figure 8    
AGG and Dormant: Total.Plants 
South Beaver Creek    
+
  geom_rect(aes(xmin=2005.75,xmax=2015.5,ymin=0,ymax=75),
                    fill="gray80", alpha=0.01) 
```{r}
head(ps.asmi.reduced)
# need not the first or last year of any plot
# Test
df <- split(ps.asmi.reduced, ps.asmi.reduced$Plot)[[1]]
ps.asmi.dormant <- do.call(rbind, lapply(split(ps.asmi.reduced, ps.asmi.reduced$Plot), function(df){
  df[-c(1,nrow(df)),]
  }))


# Total.Plants>0 should only have plots that have some plants per year so no plots from earlier than they were started
p2SBC <- ggplot(ps.asmi.dormant[ps.asmi.dormant$Creek == "SouthBeaver",], 
       aes(Year, Total.Plants, shape = Fence, colour = Fence))+
  stat_summary(fun = mean, position=position_dodge(width=0.5),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "errorbar")+
  stat_summary(fun = mean, position=position_dodge(width=0.5),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "point")+
  stat_summary(fun = mean,
               geom = "line")+
  theme_bw() +
  ylab("AGG and dormant")+
  ggtitle("b)") +
  theme(plot.title=element_text(hjust=0))+
  geom_vline(xintercept = 2005.75, lty =3)+      # Fencing put in, removed after 2015 census
  geom_vline(xintercept = 2006.75, lty = 4)+
  geom_vline(xintercept = 2015.5, lty =3) +
  scale_color_manual(values=c("#000000","#7e7e7e"),
                     labels = c("Open","Fenced"))+
  scale_shape_manual(values=c(1,2),
                     labels = c("Open","Fenced"))+
  theme(legend.justification=c(0,0), legend.position=c(0,0),  #bottom left
        legend.background = element_rect(fill=alpha('white', 0.1)))


  
```

Cebolla AGG and Dormant = Total.Plants 
```{r}


p2CC <- ggplot(ps.asmi.dormant[ps.asmi.dormant$Creek == "Cebolla",], 
       aes(Year, Total.Plants, shape = as.factor(Site), colour = as.factor(Site)))+
  stat_summary(fun = mean, position=position_dodge(width=0.05),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "errorbar")+
  stat_summary(fun = mean, position=position_dodge(width=0.05),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "point")+
  stat_summary(fun = mean,
               geom = "line")+
  theme_bw() +
  ylab("AGG and dormant")+
  ggtitle("f)") +
  theme(plot.title=element_text(hjust=0))+
  scale_color_manual("Site",
                     values=c("#000000","#7e7e7e"),
                     labels = c("Cebolla Mid","Cebolla North"))+
  scale_shape_manual("Site",
                     values=c(1,2),
                     labels = c("Cebolla Mid","Cebolla North"))+
  theme(legend.justification=c(1,1), legend.position=c(0.95,0.99),
        legend.background = element_rect(fill=alpha('white', 0.1))) 

```


South Beaver
Figure 3
AGG
```{r}


p1SBC <- ggplot(ps.asmi.reduced[ps.asmi.reduced$Site > 3,], 
       aes(Year, Total.Alive, shape = Fence, colour = Fence))+
  stat_summary(fun = mean, position=position_dodge(width=0.5),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "errorbar")+
  stat_summary(fun = mean, position=position_dodge(width=0.5),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "point")+
  stat_summary(fun = mean,
               geom = "line")+
  theme_bw() +
  ylab("Above Ground Growth")+
  ggtitle("a)") +
  theme(plot.title=element_text(hjust=0))+
  geom_vline(xintercept = 2005.75, lty =3)+      # Fencing put in, removed after 2015 census
  geom_vline(xintercept = 2006.75, lty = 4)+
  geom_vline(xintercept = 2015.5, lty =3) +
  scale_color_manual(values=c("#000000","#7e7e7e"),
                     labels = c("Open","Fenced"))+
  scale_shape_manual(values=c(1,2),
                     labels = c("Open","Fenced"))+
  theme(legend.justification=c(1,1), legend.position=c(0.35,1),
        legend.background = element_rect(fill=alpha('white', 0.1))) 


```

Cebolla    
AGG   Total.Alive     
AGG + Dormant   Total.Plants
```{r}

p1CC <- ggplot(ps.asmi.reduced[ps.asmi.reduced$Site < 3,], 
       aes(Year, Total.Alive, shape = as.factor(Site), colour = as.factor(Site)))+
  stat_summary(fun = mean, position=position_dodge(width=0.15),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "errorbar")+
  stat_summary(fun = mean, position=position_dodge(width=0.15),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "point")+
  stat_summary(fun = mean, position=position_dodge(width=0.15),
               geom = "line")+
  theme_bw() +
  ylab("Above Ground Growth")+
  ggtitle("e)") +
  theme(plot.title=element_text(hjust=0))+
  scale_color_manual("Site",
                     values=c("#000000","#7e7e7e"),
                     labels = c("Cebolla Mid","Cebolla North"))+
  scale_shape_manual("Site",
                     values=c(1,2),
                     labels = c("Cebolla Mid","Cebolla North"))+
  scale_x_continuous(breaks = c(2014:currentyr))+
  theme(legend.justification=c(1,1), legend.position=c(0.75,1),
        legend.background = element_rect(fill=alpha('white', 0.1))) 


```



Fruit   
South Beaver Creek
```{r}


p3SBC <- 
  ps.asmi.reduced %>%
  filter(Site > 3) %>%
  mutate(Total.Fruit = log(Total.Fruit)) %>%
  ggplot(  
       aes(Year, Total.Fruit, shape = Fence, colour = Fence))+
  stat_summary(fun = mean, position=position_dodge(width=0.5),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "errorbar")+
  stat_summary(fun = mean, position=position_dodge(width=0.5),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "point")+
  stat_summary(fun = mean,position=position_dodge(width=0.5),
               geom = "line")+
  theme_bw() +
  ylab("log(Total Fruit)")+
  ggtitle("c)") +
  theme(plot.title=element_text(hjust=0))+
  geom_vline(xintercept = 2005.75, lty =3)+      # Fencing put in, removed after 2015 census
  geom_vline(xintercept = 2006.75, lty = 4)+
  geom_vline(xintercept = 2015.5, lty =3) +
  scale_color_manual(values=c("#000000","#7e7e7e"),
                     labels = c("Open","Fenced"))+
  scale_shape_manual(values=c(1,2),
                     labels = c("Open","Fenced"))+
  theme(legend.justification=c(1,1), legend.position=c(1,1),
        legend.background = element_rect(fill=alpha('white', 0.1))) #upper right

```


Cebolla
```{r}

aggregate(Total.Fruit~Site+Year,data=ps.asmi.reduced[ps.asmi.reduced$Site < 3,], mean)

aggregate(Total.Fruit~Site+Year,data=ps.asmi.reduced[ps.asmi.reduced$Site<3,],
          std.error)


p3CC <- 
  ps.asmi.reduced %>%
  filter(Site < 3) %>%
  mutate(Total.Fruit = log(Total.Fruit)) %>%
  ggplot( 
       aes(Year, Total.Fruit, shape = as.factor(Site), colour = as.factor(Site)))+
  stat_summary(fun = mean, position=position_dodge(width=0.15),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "errorbar")+
  stat_summary(fun = mean, position=position_dodge(width=0.15),
               geom = "point")+
  stat_summary(fun = mean,position=position_dodge(width=0.15),
               geom = "line")+
  theme_bw() +
  ylab("log(Total Fruit)")+
  ggtitle("g)") +
  theme(plot.title=element_text(hjust=0))+
  scale_color_manual("Site", 
                     values=c("#000000","#7e7e7e"),
                     labels = c("Cebolla Mid","Cebolla North"))+
  scale_shape_manual("Site", 
                     values=c(1,2),
                     labels = c("Cebolla Mid","Cebolla North"))+
  theme(legend.justification=c(0,1), legend.position=c(0,1),
        legend.background = element_rect(fill=alpha('white', 0.1)))+
  scale_x_continuous(breaks = c(2014:currentyr))

```
  
  
X..Flowered - Percent Reproductive
```{r}


p4SBC <- ggplot(ps.asmi.reduced[ps.asmi.reduced$Creek == "SouthBeaver",], 
       aes(Year, X..Flowered, shape = Fence, colour = Fence))+
  stat_summary(fun = mean, position=position_dodge(width=0.5),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "errorbar")+
  stat_summary(fun = mean, position=position_dodge(width=0.5),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "point")+
  stat_summary(fun = mean,position=position_dodge(width=0.5),
               geom = "line")+
  theme_bw() +
  ylab("% Reproductive")+
  ggtitle("d)") +
  theme(plot.title=element_text(hjust=0))+
  geom_vline(xintercept = 2005.75, lty =3)+      # Fencing put in, removed after 2015 census
  geom_vline(xintercept = 2006.75, lty = 4)+
  geom_vline(xintercept = 2015.5, lty =3) +
  scale_color_manual(values=c("#000000","#7e7e7e"),
                     labels = c("Open","Fenced"))+
  scale_shape_manual(values=c(1,2),
                     labels = c("Open","Fenced"))+
  theme(legend.justification=c(1,1), legend.position=c(1,1),  #bottom left
        legend.background = element_rect(fill=alpha('white', 0.1))) #upper right

```

Cebolla
```{r}

p4CC <- ggplot(ps.asmi.reduced[ps.asmi.reduced$Site<3,], 
       aes(Year, X..Flowered, shape = as.factor(Site), colour = as.factor(Site)))+
  stat_summary(fun = mean, position=position_dodge(width=0.15),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "errorbar")+
  stat_summary(fun = mean, position=position_dodge(width=0.15),
               fun.min = function(x) mean(x) - std.error(x),
               fun.max = function(x) mean(x) + std.error(x),
               geom = "point")+
  stat_summary(fun = mean,position=position_dodge(width=0.15),
               geom = "line")+
  theme_bw() +
  ylab("% Reproductive")+
  ggtitle("h)") +
  theme(plot.title=element_text(hjust=0))+
  scale_color_manual("Site",
                     values=c("#000000","#7e7e7e"),
                     labels = c("Cebolla Mid","Cebolla North"))+
  scale_shape_manual("Site",
                     values=c(1,2),
                     labels = c("Cebolla Mid","Cebolla North"))+
  scale_x_continuous(breaks = c(2014:currentyr))+
  theme(legend.justification=c(0,1), legend.position=c(0,1),
        legend.background = element_rect(fill=alpha('white', 0.1))) #upper right

```


Figure 3
```{r}
ggsave(paste(savepath, "Fig3a-d.jpg", sep=""),
       # Down each column
       p1SBC + p2SBC + p3SBC + p4SBC + plot_layout(ncol = 2), units = "mm", 
    dpi = 300, height = 200, width = 200)

ggsave(paste(savepath, "Fig3e-h.jpg", sep=""),
       # Down each column
       p1CC +  p2CC +p3CC + p4CC + plot_layout(ncol=2), units = "mm", dpi = 300, height = 200, width = 200)

```


# Results: Herbivory
Dormancy    
repeat lengths   
```{r}
# how many individuals are dormant at some point
ind_dorm <- do.call(rbind,lapply(split(asmi.raw,asmi.raw$AsMi_tag_id), function(x){
  if(length(grep("dormant",x$status))>0){
    data.frame(Site = unique(x$AsMi_site_id), 
               Fence = unique(x$fence), 
               Plot = unique(x$AsMi_plot_id), 
               Dorm = 1)
  } else {
    data.frame(Site = unique(x$AsMi_site_id), 
               Fence = unique(x$fence), 
               Plot = unique(x$AsMi_plot_id), 
               Dorm = 0)
    }
  }))

# is dormancy independent of fencing?
fencing_ind_dorm <- do.call(rbind,lapply(split(asmi.raw[asmi.raw$year > 2005 & asmi.raw$year < 2016 & asmi.raw$AsMi_site_id > 3,],
                                               asmi.raw$AsMi_tag_id[asmi.raw$year > 2005 & asmi.raw$year < 2016 & asmi.raw$AsMi_site_id > 3]), function(x){
  if(length(grep("dormant",x$status))>0){
    data.frame(Site = unique(x$AsMi_site_id), 
               Fence = unique(x$fence), 
               Plot = unique(x$AsMi_plot_id), 
               Dorm = 1)
  } else {
    data.frame(Site = unique(x$AsMi_site_id), 
               Fence = unique(x$fence), 
               Plot = unique(x$AsMi_plot_id), 
               Dorm = 0)
    }
  }))
chisq.test(table(fencing_ind_dorm$Dorm, fencing_ind_dorm$Fence))
# p = 0.008 so fencing likely influences dormancy 

```


AIC for annual fruit production: none or a mast year
#Episodic fruit production paragraph   
```{r}
noreproductiveyears <- aggregate(flower~AsMi_site_id+year, data=asmi.raw,
                                 function(x) if(sum(x)>0){
                                   1
                                 } else {
                                   0
                                 })
noreproductiveyears %>%
  mutate(site = case_when(AsMi_site_id == 1 ~ "Cebolla Mid",
                          AsMi_site_id == 2 ~ "Cebolla North",
                          AsMi_site_id == 5 ~ "Site 5",
                          AsMi_site_id == 15 ~ "Site 15",
                          AsMi_site_id == 19 ~ "Site 19",
                          AsMi_site_id == 26 ~ "Site 26")) %>%
  left_join(asmi.season.wide, by = c("site" = "site","year" = "Prev12")) %>%
  ungroup() %>% 
  dplyr::mutate(across(ppt_fall:tmin_winter, .fns = scale)) %>%
ggplot(  aes(ppt_winter,flower,colour=as.factor(AsMi_site_id)))+
  geom_point()+
  geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE)+
  facet_grid(~AsMi_site_id)


noreproductiveyears %>%
  mutate(site = case_when(AsMi_site_id == 1 ~ "Cebolla Mid",
                          AsMi_site_id == 2 ~ "Cebolla North",
                          AsMi_site_id == 5 ~ "Site 5",
                          AsMi_site_id == 15 ~ "Site 15",
                          AsMi_site_id == 19 ~ "Site 19",
                          AsMi_site_id == 26 ~ "Site 26")) %>%
  # mutate(Creek = case_when(AsMi_site_id < 3 ~ "Cebolla",
  #                          AsMi_site_id > 3 ~ "South Beaver")) %>%
  filter(AsMi_site_id > 3) %>% ## as of 2022, no years with no reproduction
  left_join(asmi.season.wide, by = c("site" = "site","year" = "Prev12")) %>%
  ungroup() %>% 
  dplyr::mutate(across(ppt_fall:tmin_winter, .fns = scale)) %>%
ggplot(  aes(tmax_springSummer,flower))+#,colour=as.factor(AsMi_site_id)))+
  geom_point()+
  xlab("Summer maximum temperature")+
  geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE)#+
  # facet_grid(~Creek, scales = "free")

## exclude Cebolla creek that has never had a year without seeding
mastseeding <- noreproductiveyears %>%
  mutate(site = case_when(AsMi_site_id == 1 ~ "Cebolla Mid",
                          AsMi_site_id == 2 ~ "Cebolla North",
                          AsMi_site_id == 5 ~ "Site 5",
                          AsMi_site_id == 15 ~ "Site 15",
                          AsMi_site_id == 19 ~ "Site 19",
                          AsMi_site_id == 26 ~ "Site 26")) %>%
  mutate(Creek = case_when(AsMi_site_id < 3 ~ "Cebolla",
                           AsMi_site_id > 3 ~ "South Beaver")) %>%
  left_join(asmi.season.wide, by = c("site" = "site","year" = "Prev12"))%>%
  ungroup() %>% 
  dplyr::mutate(across(ppt_fall:tmin_winter, .fns = scale)) %>%
  filter(AsMi_site_id > 3) ## as of 2022, no years with no reproduction

glm1 <- glm(flower ~ ppt_winter*site, family = binomial, data = mastseeding)
glm2 <- glm(flower ~ tmax_springSummer*ppt_winter*site, family = binomial, data = mastseeding)
glm3 <- glm(flower ~ tmin_winter*ppt_winter*site, family = binomial, data = mastseeding) 
glm4 <- glm(flower ~ ppt_fall*site, family = binomial, data = mastseeding)
glm5 <- glm(flower ~ 1*site, family = binomial, data = mastseeding)
glm6 <- glm(flower ~ ppt_springSummer*site, family = binomial, data = mastseeding)
glm7 <- glm(flower ~ tmax_springSummer*site, family = binomial, data = mastseeding) 
glm8 <- glm(flower ~ tmin_winter*site, family = binomial, data = mastseeding)
glm.list <- list(glm1,glm2,glm3,glm4,glm5,glm6,glm7,glm8)
glm.names <- as.character(unlist(lapply(glm.list,formula)))
(glm.results <- aictab(glm.list, modnames=glm.names))
for(i in 2:length(glm.list)){
  print(exp(0.5*glm.results$Delta_AICc[i]))
}

```

## AIC figures for figure 4 of AIC results
```{r}

Fig4emastseed <- noreproductiveyears %>%
  mutate(site = case_when(AsMi_site_id == 1 ~ "Cebolla Mid",
                          AsMi_site_id == 2 ~ "Cebolla North",
                          AsMi_site_id == 5 ~ "Site 5",
                          AsMi_site_id == 15 ~ "Site 15",
                          AsMi_site_id == 19 ~ "Site 19",
                          AsMi_site_id == 26 ~ "Site 26")) %>%
  left_join(asmi.season.wide, by = c("site" = "site","year" = "Prev12")) %>%
  filter(AsMi_site_id > 3) %>%
  ungroup() %>% 
  dplyr::mutate(across(ppt_fall:tmin_winter, .fns = scale)) %>%
  dplyr::mutate(ppt_winter_bin = cut(ppt_winter, breaks = 3)) %>%
  filter(AsMi_site_id > 3) %>%
ggplot(  aes(tmax_springSummer,flower, colour=site))+
  geom_point()+
  theme_bw()+
  facet_grid(~ppt_winter_bin, scales = "free", 
             labeller = labeller(ppt_winter_bin =
                                   c("(-1.82,-0.185]" = "low winter precipitation", 
                                     "(-0.185,1.45]" = "mid winter precipitation",
                                     "(1.45,3.09]" = "high winter precipitation"))
             )+
             # labeller = labeller(.cols = label_both))+
  xlab("Summer maximum temperature")+
  ylab("Fruit production by year")+
  ggtitle("e)")+
  geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE, alpha = 0.1)#+
  # facet_grid(~Creek, scales = "free")  ## for later years if Cebolla reproduction fails

###############################################################################################
## Full figure 4 AIC results
ggsave(paste(savepath, "Fig4AICresultsa-b.jpg", sep = ""),
       # a)
 (Fig4asurvCreekBr + Fig4asurvCreek)/
   # b) 
 Fig4Survabiotic +
   plot_layout(heights = c(2, 1))
, width=250, height=250,units='mm', dpi=300)

ggsave(paste(savepath, "Fig4AICresultsc-e.jpg", sep = ""),
   # c)1 and 2
       Fig4bReprodYN_site/Fig4bReprodYN/
       # d)
   Fig4Fruit/
   # e)
   Fig4emastseed
, width=250, height=350,units='mm', dpi=300)


#how many years are there no reproductive individuals per site
1-aggregate(flower~AsMi_site_id, data=noreproductiveyears,
          function(x) sum(x)/length(x))

#On average, no reproductive individuals how many years?  in 2016
mean(c(1-aggregate(flower~AsMi_site_id,
                   data=noreproductiveyears[noreproductiveyears$year<2017,],
          function(x) sum(x)/length(x))[-(1:2),2]))*(length(1995:(currentyr-1)))

#On average, no reproductive individuals how many years?  in current year
mean(c(1-aggregate(flower~AsMi_site_id, data=noreproductiveyears,
          function(x) sum(x)/length(x))[-(1:2),2]))*(length(1995:currentyr))

#Number of years of no reproductive for South Beaver Creek (not correct for Cebolla) order is 1,2,5,15,19,26
length(1995:currentyr)-aggregate(flower~AsMi_site_id, data=noreproductiveyears,sum)


```



Figure for Becky annual report 01232018
```{r}
alive.byyear <- aggregate(length~year, data=alive[alive$AsMi_site_id>3,],
                          FUN= sum)

# ggsave("Q:/Research/MEDL_folder/AsMi_yr.jpg",device="jpeg",
ggplot(alive.byyear, aes(year,length))+
  geom_line(colour="blue")+
  ggtitle("Astragalus microcymbus")+
  theme_classic()+
  ylab("Total Population")
# )
  
# write.csv(alive.byyear,"Q:/Research/MEDL_folder/AsMi_yr.csv")

```

# Indivdiuals, density at Cebolla from demography compared to point-in-time counts   
```{r}
circleplots <- pi*(3^2)

pit1.north <- 441
pit2.north <- 987

densepit1.north <- 68/pit1.north
densepit2.north <- 114/pit2.north

mean(densepit1.north,densepit2.north) # 0.154 indv/sq meter

densecebolla <- 40/circleplots

AGG.CC <- aggregate(Total.Alive ~ Site + Year, ps.asmi[ps.asmi$Site<3 & ps.asmi$Year>2013,],
                    function(x) mean(x))
averageAGG <- aggregate(Total.Alive ~ Site, AGG.CC, function(x) mean(x))
averageAGG$Total.Alive/circleplots

aggregate(Total.Alive~Creek+Year, ps.asmi, function(x) sum(x))

```

# Annual percent of AGG+Dormant in 1996 (Year 2) compared to now, by plot (so compared to second year of plots that were added)   
```{r}
AGG.pplot <- aggregate(Total.Plants ~ Site + Plot + Creek + Year, ps.asmi, function(x) sum(x))
AGG.pplot$PercentPlants <- as.numeric(NA)
#Cebolla should all be from 2015, added in 2014
AGG.pplot$PercentPlants[AGG.pplot$Site<3 & AGG.pplot$Year>2015] <-
  AGG.pplot$Total.Plants[AGG.pplot$Site<3 & AGG.pplot$Year>2015]/
  AGG.pplot$Total.Plants[AGG.pplot$Site<3 & AGG.pplot$Year==2015]

# Do all ignoring that plot 238 and 300 need to be updated to having 1997 as the second year and 598 having 2005 as its second year
'%ni%' <- Negate('%in%')
originalplots <- sort(unique(ps.asmi$Plot))
originalplots <- originalplots[originalplots %ni% c(238,300,598)]
AGG.pplot$PercentPlants[AGG.pplot$Site>2 & AGG.pplot$Year>1996 & AGG.pplot$Plot %in% originalplots] <-
  AGG.pplot$Total.Plants[AGG.pplot$Site>2 & AGG.pplot$Year>1996 & AGG.pplot$Plot %in% originalplots]/
  AGG.pplot$Total.Plants[AGG.pplot$Site>2 & AGG.pplot$Year==1996 & AGG.pplot$Plot %in% originalplots]

# 1996 added plots
AGG.pplot$PercentPlants[AGG.pplot$Site>2 & AGG.pplot$Year>1997 & AGG.pplot$Plot %in% c(238,300)] <-
  AGG.pplot$Total.Plants[AGG.pplot$Site>2 & AGG.pplot$Year>1997 & AGG.pplot$Plot %in% c(238,300)]/
  AGG.pplot$Total.Plants[AGG.pplot$Site>2 & AGG.pplot$Year==1997 & AGG.pplot$Plot %in% c(238,300)]

# 2004 addition
AGG.pplot$PercentPlants[AGG.pplot$Site>2 & AGG.pplot$Year>2005 & AGG.pplot$Plot %in% c(598)] <-
  AGG.pplot$Total.Plants[AGG.pplot$Site>2 & AGG.pplot$Year>2005 & AGG.pplot$Plot %in% c(598)]/
  AGG.pplot$Total.Plants[AGG.pplot$Site>2 & AGG.pplot$Year==2005 & AGG.pplot$Plot %in% c(598)]

ggplot(aggregate(PercentPlants ~ Site + Year, AGG.pplot, function(x) mean(x, na.rm=TRUE)),
       aes(Year, PercentPlants, colour=as.factor(Site), shape=as.factor(Site)))+
  geom_point()+
  geom_line()+
  theme_bw()

ggplot(aggregate(PercentPlants ~ Creek + Year, AGG.pplot, function(x) mean(x, na.rm=TRUE)),
       aes(Year, PercentPlants, colour=as.factor(Creek), shape=as.factor(Creek)))+
  geom_point()+
  geom_line()+
  theme_bw()
```

# Annual percent of AGG in 1995 (first year) compared to year, by plot (so compared to second year of plots that were added)   
```{r}
AGG.pplot$Total.Alive <- aggregate(Total.Alive ~ Site + Plot + Creek + Year, ps.asmi, function(x) sum(x))$Total.Alive
AGG.pplot$PercentAlive95 <- as.numeric(NA)
#Cebolla should all be from 2015
AGG.pplot$PercentAlive95[AGG.pplot$Site<3 & AGG.pplot$Year>2014] <-
  AGG.pplot$Total.Alive[AGG.pplot$Site<3 & AGG.pplot$Year>2014]/
  AGG.pplot$Total.Alive[AGG.pplot$Site<3 & AGG.pplot$Year==2014]

# Do all ignoring that plot 238 and 300 need to be updated to having 1997 as the second year and 598 having 2005 as its second year
AGG.pplot$PercentAlive95[AGG.pplot$Site>2 & AGG.pplot$Year>1995& AGG.pplot$Plot %in% originalplots] <-
  AGG.pplot$Total.Alive[AGG.pplot$Site>2 & AGG.pplot$Year>1995& AGG.pplot$Plot %in% originalplots]/
  AGG.pplot$Total.Alive[AGG.pplot$Site>2 & AGG.pplot$Year==1995& AGG.pplot$Plot %in% originalplots]

# 1996 added plots
AGG.pplot$PercentAlive95[AGG.pplot$Site>2 & AGG.pplot$Year>1996 & AGG.pplot$Plot %in% c(238,300)] <-
  AGG.pplot$Total.Alive[AGG.pplot$Site>2 & AGG.pplot$Year>1996 & AGG.pplot$Plot %in% c(238,300)]/
  AGG.pplot$Total.Alive[AGG.pplot$Site>2 & AGG.pplot$Year==1996 & AGG.pplot$Plot %in% c(238,300)]

# 2004 addition
AGG.pplot$PercentAlive95[AGG.pplot$Site>2 & AGG.pplot$Year>2004 & AGG.pplot$Plot %in% c(598)] <-
  AGG.pplot$Total.Alive[AGG.pplot$Site>2 & AGG.pplot$Year>2004 & AGG.pplot$Plot %in% c(598)]/
  AGG.pplot$Total.Alive[AGG.pplot$Site>2 & AGG.pplot$Year==2004 & AGG.pplot$Plot %in% c(598)]

ggplot(aggregate(PercentAlive95 ~ Site + Year, AGG.pplot, function(x) mean(x, na.rm=TRUE)), 
       aes(Year, PercentAlive95, colour=as.factor(Site), shape = as.factor(Site)))+
  geom_point()+
  geom_line()+
  theme_bw()

plotfenced <- unique(ps.asmi$Plot[ps.asmi$Fence=="y"])

aggregate(PercentAlive95 ~ Site + Year, AGG.pplot[AGG.pplot$Plot %in% plotfenced,], function(x) mean(x, na.rm=TRUE))
```

# Annual percent of AGG in 1996 compared to each year, by plot (so compared to second year of plots that were added)   
```{r}
# AGG.pplot <- aggregate(Total.Alive ~ Site + Plot + Creek + Year, ps.asmi, function(x) sum(x))
AGG.pplot$PercentAlive96 <- as.numeric(NA)
#Cebolla should all be from 2015
AGG.pplot$PercentAlive96[AGG.pplot$Site<3 & AGG.pplot$Year>2015] <-
  AGG.pplot$Total.Alive[AGG.pplot$Site<3 & AGG.pplot$Year>2015]/
  AGG.pplot$Total.Alive[AGG.pplot$Site<3 & AGG.pplot$Year==2015]

# Do all ignoring that plot 238 and 300 need to be updated to having 1997 as the second year and 598 having 2005 as its second year
AGG.pplot$PercentAlive96[AGG.pplot$Site>2 & AGG.pplot$Year>1996& AGG.pplot$Plot %in% originalplots] <-
  AGG.pplot$Total.Alive[AGG.pplot$Site>2 & AGG.pplot$Year>1996& AGG.pplot$Plot %in% originalplots]/
  AGG.pplot$Total.Alive[AGG.pplot$Site>2 & AGG.pplot$Year==1996& AGG.pplot$Plot %in% originalplots]

# 1996 added plots
AGG.pplot$PercentAlive96[AGG.pplot$Site>2 & AGG.pplot$Year>1997 & AGG.pplot$Plot %in% c(238,300)] <-
  AGG.pplot$Total.Alive[AGG.pplot$Site>2 & AGG.pplot$Year>1997 & AGG.pplot$Plot %in% c(238,300)]/
  AGG.pplot$Total.Alive[AGG.pplot$Site>2 & AGG.pplot$Year==1997 & AGG.pplot$Plot %in% c(238,300)]

# 2004 addition
AGG.pplot$PercentAlive96[AGG.pplot$Site>2 & AGG.pplot$Year>2005 & AGG.pplot$Plot %in% c(598)] <-
  AGG.pplot$Total.Alive[AGG.pplot$Site>2 & AGG.pplot$Year>2005 & AGG.pplot$Plot %in% c(598)]/
  AGG.pplot$Total.Alive[AGG.pplot$Site>2 & AGG.pplot$Year==2005 & AGG.pplot$Plot %in% c(598)]

ggplot(aggregate(PercentAlive96 ~ Site + Year, AGG.pplot, function(x) mean(x, na.rm=TRUE)), 
       aes(Year, PercentAlive96, colour=as.factor(Site), shape = as.factor(Site)))+
  geom_point()+
  geom_line()+
  theme_bw()

aggregate(PercentAlive96 ~ Plot + Year, AGG.pplot, function(x) x)$PercentAlive96

aggregate(PercentAlive96 ~ Creek + Year, AGG.pplot, function(x) mean(x, na.rm=TRUE))
```

Results: Density (AGG)
```{r}

popsizes <- aggregate(Total.Alive ~ Site + Creek + Fence + Year, ps.asmi, function(x) mean(x, na.rm=TRUE))

popsizes[popsizes$Site==5,]

plot(popsizes$Year[popsizes$Site==5],popsizes$Total.Alive[popsizes$Site==5], pch=rep(c("n","y"),24))
abline(h=0)

popsizes$Total.Alive[popsizes$Site==5 & popsizes$Year==currentyr]/popsizes$Total.Alive[popsizes$Site==5 & popsizes$Year==1995]

popsizes$Total.Alive[popsizes$Site==15 & popsizes$Year==currentyr]/popsizes$Total.Alive[popsizes$Site==15 & popsizes$Year==1995]

popsizes$Total.Alive[popsizes$Site==19 & popsizes$Year==currentyr]/popsizes$Total.Alive[popsizes$Site==19 & popsizes$Year==1995]

popsizes$Total.Alive[popsizes$Site==26 & popsizes$Year==currentyr]/popsizes$Total.Alive[popsizes$Site==26 & popsizes$Year==1995]
```

Results: Fruit
```{r}
reproductive <- aggregate(X..Flowered.1 ~ Site + Year, ps.asmi, function(x) sum(x, na.rm=TRUE))

reproductive[reproductive$X..Flowered.1==0,]
rowSums(table(reproductive$Site, reproductive$Year))
length(1995:2018)

rowSums(table(reproductive$Site, reproductive$Year))[3:6]/length(1995:currentyr)

# Years with no reproduction
length(1995:currentyr)-rowSums(table(reproductive$Site, reproductive$Year))[3:6]
mean(length(1995:currentyr)-rowSums(table(reproductive$Site, reproductive$Year))[3:6])

# Percent of years that are reproductive
mean(rowSums(table(reproductive$Site, reproductive$Year))[3:6]/length(1995:currentyr))
```

Results: herbivory
```{r}
asmi.raw.fenced <- asmi.raw[asmi.raw$year > 2005 & asmi.raw$year < 2016 & 
                              asmi.raw$Creek == "SouthBeaver",]

table(asmi.raw$Browsing...Status)[-5]/sum(table(asmi.raw$Browsing...Status)[-5])

table(asmi.raw.fenced$Browsing...Status,asmi.raw.fenced$fence)[-5,]/colSums(table(asmi.raw.fenced$Browsing...Status,asmi.raw.fenced$fence)[-5,])

# Herbivory by insects (removing Unknown)
sum(table(asmi.raw$Browsing...Status)[c(1,3)])/sum(table(asmi.raw$Browsing...Status)[-5])

colSums(table(asmi.raw.fenced$Browsing...Status,asmi.raw.fenced$fence)[c(1,3),])/colSums(table(asmi.raw.fenced$Browsing...Status,asmi.raw.fenced$fence)[-5,])

# Herbivory by mammals (removing Unknown)
sum(table(asmi.raw$Browsing...Status)[c(2,3)])/sum(table(asmi.raw$Browsing...Status)[-5])
colSums(table(asmi.raw.fenced$Browsing...Status,asmi.raw.fenced$fence)[c(2,3),])/colSums(table(asmi.raw.fenced$Browsing...Status,asmi.raw.fenced$fence)[-5,])

# is level of browsing independent of the fencing treatment?
chisq.test(table(asmi.raw.fenced$Browsing...Status,asmi.raw.fenced$fence)[-c(4:5),]) # remove no browsing and unknown
# p-value = 0.003 unlikely that fencing is independent of amounts of types of browsing, fencing changes the amount of browsing by type (insect, mammal, both), type of browsing is not likely independent of fencing

chisq.test(table(asmi.raw.fenced$Browsing...Status,asmi.raw.fenced$fence)[-c(5),]) # remove no browsing and unknown
# p-value < 0.001 means it is unlikely independent of fencing by different types of browsing

# browsing or no browsing
chisq.test(table(asmi.raw.fenced$browsing,asmi.raw.fenced$fence))
# during the time fencing was installed, it seems the probability of being browsed in a plot depends on the plot being fenced

```

Discussion: percent of dormant indivdiuals
```{r}

ps.asmi$PercentDorm <- ps.asmi$X..Dormant/sum(ps.asmi$Total.Alive,ps.asmi$Total.Plants, na.rm=TRUE)  
aggregate(PercentDorm~Year, ps.asmi, function(x) mean(x, na.rm=TRUE))  
```




Reproductive lengths - South Beaver Creek only   
```{r}
levels(asmi.1$status)
# [1] "seedling"     "vegetative"   "reproductive" "dormant"      "dead"

repros <- do.call(rbind, lapply(split(asmi.1, asmi.1$AsMi_tag_id), function(tag){
  reprolns <- rle(as.numeric(tag$status))$lengths[rle(as.numeric(tag$status))$values==3]
  out <- data.frame(Tag=rep(unique(tag$AsMi_tag_id), length(reprolns)), 
                    Site=rep(unique(tag$AsMi_site_id), length(reprolns)),
                    Plot=rep(unique(tag$AsMi_plot_id), length(reprolns)),
                    repros=reprolns)
  out
}))

# max(repros$reproslength)
max(repros$repros) # 8
repros[repros$repros == max(repros$repros),]

repros[repros$repros == max(repros$repros)-4,]

plotrepros <- data.frame(table(repros$Tag, repros$repros)) #Var1 is tag, Var2 is reprolenth, Freq times
mean(plotrepros$Freq[plotrepros$Var2==1])

ggplot(plotrepros, aes(x=Var2, y=Freq ))+
  geom_boxplot()+ 
  theme(legend.position="none")

```

```{r}
#is survival associated with a continuous classifying variable?
surv.asmi <- asmi.all2  # asmi.2
surv.asmi$surv <- 1
surv.asmi$surv[surv.asmi$fate=="dead"] <- 0
table(surv.asmi$surv)

str(surv.asmi)

#stages are L, Q, and C? linear, quadractic, cubic - because of the ordinal factor, just factor it
summary(glm(surv~ as.factor(as.numeric(stage)) +as.factor(site), family=binomial(link = "logit"), surv.asmi))
# overall survival is 23% SE 6.6% more for vegetative, more for reproductive but misleading for dormant because we can't observe them dying. less for site 19, more for site 5

surv.asmi$stage <- factor(surv.asmi$stage, levels=levels(surv.asmi$stage), ordered=FALSE)
str(surv.asmi)
summary(glm(surv~ stage +as.factor(site), family=binomial(link = "logit"), surv.asmi))


#survival as a cox proportional hazards regression model
library(survival)

# interval data, the starting time for the interval (so the year is the stage year and survival is based on fate, next year); "righ censoring" means date of death is unknown, which it is actually! 
#Survival curve is probability that time of death is greater than some specified time
survObj <- Surv(time = surv.asmi$year, event=as.logical(surv.asmi$surv))
model <- coxph(survObj ~ strata(factor(site)), data=surv.asmi)
model <- coxph(survObj ~ as.factor(site), data=surv.asmi)
summary(model)

model_fence <- coxph(survObj ~ fenced, data=surv.asmi)
summary(model_fence)

model_fence_site <- coxph(survObj ~ fenced*site, data=surv.asmi)
summary(model_fence_site)

model_stage <- coxph(survObj ~ stage, data=surv.asmi)
summary(model_stage)

#plotting time to death


```


https://rpubs.com/daspringate/survival    
https://datascience.stackexchange.com/questions/8162/r-plotsurv-newdata-draws-same-lines-many-times-why    


```{r}
#plot survival of a given year by size
for(i in sort(unique(surv.asmi$year))){
  plot(surv.asmi$length[surv.asmi$year==i], 
       surv.asmi$surv[surv.asmi$year==i], main= paste(i), xlab="length",ylab="Probability of survival")
  g<- glm(surv~length, family=binomial,surv.asmi[surv.asmi$year==i,])
  curve(predict(g,data.frame(length=x),type="resp"), col="green4",add=TRUE)
  #points(surv.asmi$length[surv.asmi$year==i],fitted(g), pch=20)
}

plot(surv.asmi$length, 
       surv.asmi$surv, main= "1996 - 2017", xlab="length",ylab="Probability of survival")
  g<- glm(surv~length, family=binomial,surv.asmi)
  curve(predict(g,data.frame(length=x),type="resp"), col="green4",add=TRUE)

# Plot survivial per year by fruit
for(i in sort(unique(surv.asmi$year))){
  plot(surv.asmi$fruits[surv.asmi$year==i], 
       surv.asmi$surv[surv.asmi$year==i], main= paste(i), xlab="fruits",ylab="Probability of survival")
  g<- glm(surv~fruits, family=binomial,surv.asmi[surv.asmi$year==i,])
  curve(predict(g,data.frame(fruits=x),type="resp"), col="green4",add=TRUE)
  #points(surv.asmi$length[surv.asmi$year==i],fitted(g), pch=20)
}
  
  
plot(surv.asmi$fruits, 
       surv.asmi$surv, main= "1996 - 2017", xlab="fruits",ylab="Probability of survival")
  g<- glm(surv~fruits, family=binomial,surv.asmi)
  curve(predict(g,data.frame(fruits=x),type="resp"), col="green4",add=TRUE)
  

surv.asmi$frYN <- 0
surv.asmi$frYN[surv.asmi$fruits>0] <- 1

# Probability of being reproductive given length
for(i in sort(unique(surv.asmi$year))){
  plot(surv.asmi$length[surv.asmi$year==i], 
       surv.asmi$frYN[surv.asmi$year==i], main= paste(i), xlab="length",ylab="Probability of reproductive")
  g<- glm(frYN~length, family=binomial,surv.asmi[surv.asmi$year==i,])
  curve(predict(g,data.frame(length=x),type="resp"), col="green4",add=TRUE)
}
    
plot(surv.asmi$length, 
       surv.asmi$frYN, main= "1996 - 2019", xlab="length",ylab="Probability of reproductive")
  g<- glm(frYN~length, family=binomial,surv.asmi)
  curve(predict(g,data.frame(length=x),type="resp"), col="green4",add=TRUE)  
  
```


Does this not only want the max YrsAlive per tag? Yes I think so 
# Another way to look at survival curves
```{r}
fit <- survfit(Surv(length, surv) ~ fenced, 
               data = surv.asmi[surv.asmi$length>0 & surv.asmi$year>2005,]) 

# jpeg(paste("Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/Asmi_Excel/Yearly Summaries/",
#               currentyr,"_asmi/Fig9_Surv_fence_size.jpg", sep = ""),
#          units = "mm", res = 300, height = 100, width = 150)

ggsurvplot(fit, data=surv.asmi[surv.asmi$length>0 & surv.asmi$year>2005,], 
           risk.table = FALSE, xlab = "length", conf.int = TRUE)

# dev.off()
```

# Fit these with dampening survival estimates? based on what are likely to be seen in the rest of the year but dormant in July? 


```{r}
fit <- survfit(Surv(length, surv) ~ site, 
               data = surv.asmi[surv.asmi$length>0 & surv.asmi$year>2005,]) 

ggsurvplot(fit, data=surv.asmi[surv.asmi$length>0& surv.asmi$year>2005,], risk.table = FALSE, xlab = "length")

```



############################# 

```{r}

asmi.raw.1 <- asmi.raw[with(asmi.raw, order(AsMi_site_id,AsMi_plot_id,AsMi_tag_id,year)),]

asmi.raw.1[asmi.raw.1$AsMi_tag_id==10,]
asmi.1[asmi.1$AsMi_tag_id==10,] # Alive in 1995, not detected again until 2004 when big and flowering
asmi.1[asmi.1$AsMi_tag_id==3,] # in 1996, maybe these were seen in 1995 but dead by 1996?
asmi.1[asmi.1$AsMi_tag_id==11,] # Some tag made in error I guess

#Probability of being reproductive given years alive
levels(asmi.raw.1$status) # 3 is reproductive; 1 is dead
# Should add at least 1 year to the years alive if reproductive 
# test
x <- split(asmi.raw.1, asmi.raw.1$AsMi_tag_id)[[100]]

## not quite appropriate for survival analysis. Example is from a set time, diagnosis of cancer, to how long after is survival and then right censoring to say measured up until a time but don't know after that if still alove vs. measured through to this time and died then 'status = 0 if stopped measuring and 1 if dead at that time. 

notdeadyet <- do.call(rbind,lapply(split(asmi.raw.1, asmi.raw.1$AsMi_tag_id), function(x){
  if(nrow(x[x$status!="dead",])>0){
    if(x$status[1] == "reproductive"){ # if the first year was reproductive then it wasn't a seedling for sure
      addyear <- 1
    } else {
      addyear <- 0
    }
    StageLength <- nrow(x[x$status!="dead",])
    data.frame(Tag=x$AsMi_tag_id[x$status!="dead"],
               year = x$year[x$status!="dead"],
               YrsAlive=(1+addyear):(StageLength+addyear))
    }
  }))

surv.asmi.1 <- merge(asmi.raw, notdeadyet, by.x = c("AsMi_tag_id","year"), by.y = c("Tag","year"))
surv.asmi.1[surv.asmi.1$AsMi_tag_id==10,]
surv.asmi.1[surv.asmi.1$status=="reproductive"&surv.asmi.1$YrsAlive<3,]

surv.asmi.1$frYN <- 0
surv.asmi.1$frYN[surv.asmi.1$fruit>0] <- 1

# Probability of being reproductive given length alive

plot(surv.asmi.1$YrsAlive, 
       surv.asmi.1$frYN, main= "1995 - 2018", xlab="Years alive",ylab="Probability of reproductive")
  g<- glm(frYN~YrsAlive, family=binomial,surv.asmi.1)
  curve(predict(g,data.frame(YrsAlive=x),type="resp"), col="green4",add=TRUE)  
  

```

Does this not only want the max YrsAlive per tag?
```{r}
surv.asmi.2 <- merge(surv.asmi, notdeadyet, by.x=c("tag","year"), by.y=c("Tag","year"))

fit <- survfit(Surv(YrsAlive, surv) ~ site, 
               data = surv.asmi.2[surv.asmi.2$length>0,]) 

ggsurvplot(fit, data=surv.asmi.2[surv.asmi.2$length>0,], risk.table = FALSE, xlab = "Age", ylab="Probability of Reproductive")

```

```{r}
plot(10,10, type="n")
matplot(contr.poly(15)[,1:4], type="b") 
```



# Integral Projection Models    
Janeiro et al. 2017 Towards robust evolutionary...
Rees et al. 2014 Constructing IPMs when more than one census is available (Appendix S4) and others and the main paper, Building integral projeciton models: a user's guide

# Mark-recapture
<http://www.montana.edu/rotella/documents/502/lab07RMark.html>    
Laake and Rexstad 2008
Alexander et al. 2009 Detection, survival rates...
Chen et al. 2009 Factors affecting detection...
MacKenzie et al. 2009 Modeling species occurrence dynamics...
Kellner and Swihart 2014 Accounting for Imperfect detection...
Chandler et al. 2018 Estimating recruitment from capture-recapture data...
Mark-recapture   
```{r, eval=FALSE}

library(RMark)

# Convert dataset into capture histories  
head(asmi.raw)
table(asmi.raw$AsMi_tag_id[asmi.raw$length>0],asmi.raw$year[asmi.raw$length>0])


```

Autoregressive and moveing average modeling method   (Liu and Guo 2019)   
     find the order p and q of the ARMA(p,q) from the autocorrelation and parial correlation coefficient 
     Can find the time domain and frequency domain of data
     Should be able to figure out the current priodic mast seeding and then model if it increases or decreases, the impact on future growth of AsMi    
     tailing means that either ACF or PACF
does not approach to 0 at each lag order, and truncation on
order p and q means ACF and PACF   
Fruit is episodic, mast seeding, would make sense to add a sin and/or cos wave to the fit    
```{r, eval=FALSE}
library(astsa)

head(asmi.raw)
ps.ts <- aggregate(Total.Fruitlogtransformed.x~Year.x, data=ps.cor, sum)
asmi.raw.ts <- aggregate(fruit~year+AsMi_site_id, data=asmi.raw, sum)

co2 <- ts(ps.ts$Total.Fruitlogtransformed.x, frequency = 1, start = c(1995,1))
plot(co2, xlab="Year", ylab = "Fruit")

co25 <- ts(asmi.raw.ts$fruit[asmi.raw.ts$AsMi_site_id==5], frequency=1, start=c(1995,1))
plot(co25, xlab="Year", ylab = "Fruit")

co215 <- ts(asmi.raw.ts$fruit[asmi.raw.ts$AsMi_site_id==15], frequency=1, start=c(1995,1))
plot(co215, xlab="Year", ylab = "Fruit")


co219 <- ts(asmi.raw.ts$fruit[asmi.raw.ts$AsMi_site_id==19], frequency=1, start=c(1995,1))
plot(co219, xlab="Year", ylab = "Fruit")

co226 <- ts(asmi.raw.ts$fruit[asmi.raw.ts$AsMi_site_id==26], frequency=1, start=c(1995,1))
plot(co226, xlab="Year", ylab = "Fruit")

co21 <- ts(asmi.raw.ts$fruit[asmi.raw.ts$AsMi_site_id==1], frequency=1, start=c(2014,1))
co2_2 <- ts(asmi.raw.ts$fruit[asmi.raw.ts$AsMi_site_id==2], frequency=1, start=c(2014,1))


plot(co25, xlab="Year", ylab = "Fruit", ylim=c(0,15050))
lines(co215, col="red")
lines(co219, col="cyan")
lines(co226, col="blue")
lines(co21, col="orange")
lines(co2_2, col="green")

```

Steps for model order selection   
     1. residual vaiogram   
     2. order determination using F test   
     3. order estimation with AIC and BIC   
     4. Parameter estimations with moment estimation and least square and maximum likelihood estimation    
      
      
Low order moment estimation can be solved directly, high order obtained using linear iterative or Newton-Raphson method. 

Autoregressive AR(p)
Moving average MA(q)
ARMA(p,q)      
arima() estimates underlying mean of time series unless d?0
x_t = mu + rho(x_t-1 - mu) + white noise  

Simulate stationary processes  
```{r, eval=FALSE}
## ARMA(2,2) description for arim.sim()
ARMA22 <- list(order=c(2,0,2), ar=c(-0.7,0.2), ma=c(0.7,0.2))
## mean of process
mu <- 5
## simulated process (+ mean) , big sample size
ARMA.sim <- arima.sim(n=10000, model=ARMA22) + mu
## estimate parameters
arima(x=ARMA.sim, order=c(2,0,2))
```

<https://nwfsc-timeseries.github.io/atsa-labs/chap-tslab.html#data-and-packages-1> 
```{r}
# library(devtools)
# devtools::install_github("nwfsc-timeseries/atsalibrary")

```

<https://www.itl.nist.gov/div898/handbook/pmc/section4/pmc44a.htm>    
```{r, eval=FALSE}
# R commands and output:

## Read the data and save as a time series object.
table = read.table("G_SERIES.DAT", skip=25)
vec = ts(table)

## Load the necessary libraries.
library(stats)
library(lawstat)

## Plot the data print summary statistics.
par(mfrow=c(1,1), cex=1.2)
plot(1:length(vec),vec, type="o", pch=18, col="blue",
     xlab = "Observation", ylab="Series G")
print(summary(vec))

## Take natural log of original series and plot the results.
lvec = log(vec)
par(mfrow=c(1,1), cex=1.2)
plot(1:length(vec),lvec, type="o", pch=18, col="red",
	xlab = "Observation", ylab="ln(Series G)")

## Take first differences of transformed series to remove trend 
## and plot the transformed and differenced data.
fd = diff(lvec)
par(mfrow=c(1,1), cex=1.2)
plot(fd, type="o", pch=18,  col="darkblue",
	xlab = "Observation", ylab="Differenced ln(Series G)")

## Compute the autocorrelation of the transformed and differenced series.
ac <- acf(fd, type = c("correlation"), lag.max=36, main="Autocorrelation of Series G")

## Print ACF for first 36 lags.
round(c(ac$acf),4)

##>  [1]  1.0000  0.1998 -0.1201 -0.1508 -0.3221 -0.0840  0.0258 -0.1110 -0.3367
##> [10] -0.1156 -0.1093  0.2059  0.8414  0.2151 -0.1396 -0.1160 -0.2789 -0.0517
##> [19]  0.0125 -0.1144 -0.3372 -0.1074 -0.0752  0.1995  0.7369  0.1973 -0.1239
##> [28] -0.1027 -0.2110 -0.0654  0.0157 -0.1154 -0.2893 -0.1269 -0.0407  0.1474
##> [37]  0.6574

## Plot the ACF with 95 % confidence limits.
par(mfrow=c(1,1), cex=1.2)
plot(ac, ci=.95, ci.type="ma", main="ACF with 95 % Confidence Limits",
     ylim=c(-1,1))

##  Take seasonal differences of the transformed and differenced series.
sfd = diff(fd, lag=12)

## Plot final time series.
par(mfrow=c(1,1), cex=1.2)
plot(sfd, type="o", pch=18,  col="red", xlab = "Observation", 
     ylab="Seasonal and First Differenced ln(Series G)")

## Compute autocorrelation of final series.
sac = acf(sfd, type = c("correlation"), lag.max=36, 
           main="Autocorrelation of Series G")

## Plot the ACF of differenced series with 95 % confidence limits.
par(mfrow=c(1,1), cex=1.2)
plot(sac, ci=.95, ci.type="ma", main="ACF with 95 % Confidence Limits",
     ylim = c(-1,1))

## Fit a MA model to original series.  The arima function will 
## perform the necessary differences.
ma = arima(log(vec), order = c(0, 1, 1), 
            seasonal=list(order=c(0,1,1), period=12))
ma

##> Call:
##> arima(x = log(vec), order = c(0, 1, 1), seasonal = list(order = c(0, 1, 1), 
##>     period = 12))

##> Coefficients:
##>           ma1     sma1
##>       -0.4018  -0.5569
##> s.e.   0.0896   0.0731

##> sigma^2 estimated as 0.001348:  log likelihood = 244.7,  aic = -483.4

## Use the Box-Ljung test to determine if the residuals are 
## random up to 30 lags.
BT = Box.test(ma$residuals, lag=30, type = "Ljung-Box", fitdf=2)
BT

##>         Box-Ljung test
##> 
##> data:  ma$residuals 
##> X-squared = 29.4935, df = 30, p-value = 0.3878

## Although the output indicates that the degrees of freedom for 
## the test are 30, the p-value is based on df-fitdf = 30-2 = 28.
1-pchisq(29.4935,28)

##> [1] 0.3878282

## Determine critical region.
qchisq(0.95,28)

##> [1] 41.33714

## Generate predictions of 12 future values.
p = predict(ma,12)

## Compute 90% confidence intervals for each prediction
## and convert back to original units.
L90 = exp(p$pred - 1.645*p$se)
U90 = exp(p$pred + 1.645*p$se)

## Generate forecasts in original units.  To avoid under-predicting,
## the forecasts are adjusted to account for log transformation.
Forecast = exp(p$pred + ma$sigma2/2)

## Print the forecast results.
Period = c((length(vec)+1):(length(vec)+12))
df = data.frame(Period,L90,Forecast,U90)
print(df,row.names=FALSE)

##>   Period      L90 Forecast      U90
##>      145 424.0234 450.7261 478.4649
##>      146 396.7861 426.0042 456.7577
##>      147 442.5731 479.3298 518.4399
##>      148 451.3902 492.7365 537.1454
##>      149 463.3034 509.3982 559.3245
##>      150 527.3754 583.7383 645.2544
##>      151 601.9371 670.4625 745.7830
##>      152 595.7602 667.5274 746.9323
##>      153 495.7137 558.5657 628.5389
##>      154 439.1900 497.5430 562.8899
##>      155 377.7598 430.1618 489.1730
##>      156 417.3149 477.5643 545.7760

## Plot last 36 observations and the predictions with confidence limits.
par(mfrow=c(1,1), cex=1.2)
plot(c(108:144),table[108:144],xlim=c(108,160),ylim=c(300,800), type="o",
     ylab="Series G", xlab="Observation", col="black",
     main="12 Forecasts and 90% Confidence Intervals")
points(Forecast, pch=16, col="blue")
lines(c(145:156), L90, col="red")
lines(c(145:156), U90, col="red")

```


# Add error and variance to dormancy
# change dormant to reproductive, seedling???, or vegetative in a given year based on climate   
```{r, eval=FALSE}
# relationship of climate and likelyhood of being stage given climate; ppt.springSummer best descriptor of status in July
season




```


Going to skip this after 2016 since know that plants aren't below ground the whole season, not as much a question of using this to figure out how much dormancy - dormancy = not AGG in July   
Need to change from set amount of time dormant to find the most likely length of dormancy given that 25-50 percent are actually veg, seedlings, or reproductive when not detected in July

### Years alive    
```{r, eval=FALSE}
dormyrs <- currentyr-1995

path <- paste("Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/Asmi_Excel/Yearly Summaries/",
              currentyr,
              "_asmi/", collapse = '', sep = '')

#If a plant is still alive in the current year, there is no years alive calculated
yrsalive <- lapply(1:(dormyrs-1), function(x){ 
  path2 <- paste(path, "YrsAlive_dormant", x, ".csv", sep = "")
  ysal <- read.csv(path.expand(path2), na.strings="na")
  ysal <- cbind(ysal, YrsD = x)
  ysal[complete.cases(ysal),]
  })

head(yrsalive[[4]])

```




#SKIP!




#autocorrelations   
https://campus.datacamp.com/courses/introduction-to-time-series-analysis/correlation-analysis-and-the-autocorrelation-function?ex=9#next    
alive.site$length are the number of indiviudals with length>0 and that aren't na per site per year (and per fenced or not plots)
```{r, eval=FALSE}
# Not sure what trying to do? Take away the first row each time?
# length_tmin1 <- split(alive.site$length[-1],alive.site$AsMi_site_id)
length_tmin1 <- split(alive.site$length,alive.site$AsMi_site_id)
length_tmin1.removed <- lapply(length_tmin1, function(x) x[-1])

# length_t <- split(alive.site$length[-nrow(alive.site)],
#                         alive.site$AsMi_site_id)

length_t.removed <- lapply(length_tmin1, function(x) x[-length(x)])
length_tmin1.removed
length_t.removed

autocor <- mapply(cbind,length_t.removed,length_tmin1.removed)
```

```{r, eval=FALSE}
plot(autocor[[1]], xlim=c(0,325), ylim=c(0,350), pch=20)
for(i in 2:6){
  points(autocor[[i]], col=i, pch=20)
}
```

```{r, eval=FALSE}
autocor1 <- do.call(rbind,autocor)
# sample covariance in acf is scaled with 1/(n-1) instead of 1/n
cor(autocor1[,1],autocor1[,2])*(nrow(autocor1)/(nrow(autocor1)+1))

#but to combine all sites time series, need to keep steps separate by site
lapply(split(alive.site$length,alive.site$AsMi_site_id), function(x){
  acf(x, lag.max=15, plot=TRUE)
})

#Blue is the 95% CI around zero, different from zero correlation
```


# 2017 June 2 for NCAR
```{r, eval=FALSE}

uniqclim <- unique(asmi.c[,c("Year","tmin","tmax","ppt")])
clim_agg <- merge(uniqclim, ps.asmi, by = "Year")


library(reshape2)
clim_agg_long <- melt(clim_agg[,c(1:6,8)], measure.vars = c("tmin","tmax","ppt","Total.Alive"))
levels(clim_agg_long$variable) <- c("Minimum temperature","Maximum temperature",
                                    "Precipitation (mm)","Individuals per plot")

ggplot(clim_agg_long[clim_agg_long$variable%in% c("Precipitation (mm)","Individuals per plot") & clim_agg_long$Site>3,], 
       aes(Year, value))+
#  geom_point()+
  stat_smooth(alpha=0.5)+
  facet_wrap(~variable, scales="free", ncol=1)+
  theme_bw()

asmi.c


ggplot(asmi.c, aes(Year, ppt))+
  geom_line()+
  facet_wrap(~Month+Site)
```

```{r, eval=FALSE}
ggplot(clim_agg_long[clim_agg_long$variable%in% c("Minimum temperature","Individuals per plot") & clim_agg_long$Site>3,], 
       aes(Year, value))+
#  geom_point()+
  stat_smooth(alpha=0.5)+
  facet_wrap(~variable, scales="free", ncol=1)+
  theme_bw()
```

```{r, eval=FALSE}
ggplot(clim_agg_long[clim_agg_long$Site>3,], 
       aes(as.factor(Year), value))+
#  geom_point()+
  stat_smooth(alpha=0.5)+
  geom_boxplot()+
  facet_wrap(~variable, scales="free", ncol=1)+
  theme_bw()
```




Figure 3: Was: Average life span of Astragalus microcymbus (with one standard error from the mean) given consecutive assumptions on length of possible whole plant dormancy. (b) Distribution of consecutive years of dormancy when dormancy is not limited.  
```{r, eval=FALSE}
ggplot(smya, aes(YrsD, Yearsalive))+
#  stat_smooth()+
  geom_errorbar(aes(ymin=Yearsalive-se, ymax=Yearsalive+se), 
                width=1) +
  theme_bw()+
  xlab("Maximum years dormant")+
  ylab("Life length")+
  scale_y_continuous(breaks = seq(2, 4, .5), limits = c(2.3, 3.8)) 

```

```{r, eval=FALSE}
sumYrsAlive <- lapply(yrsalive, function(x){
  summarySE(x[complete.cases(x),], measurevar="Yearsalive",groupvars="YrsD")
})

smya <- do.call(rbind, sumYrsAlive)

ggplot(smya, aes(YrsD, Yearsalive))+
  geom_line()

yrsaliveall <- do.call(rbind, yrsalive)

ggplot(yrsaliveall, aes(as.factor(YrsD), Yearsalive))+
  geom_violin()

# , colour= as.factor(AsMi_site_id)   
# Cebolla Creek not long enough to get at life length
ggplot(yrsaliveall[yrsaliveall$AsMi_site_id > 3,], aes(as.factor(YrsD), Yearsalive))+
  # geom_boxplot()+
  geom_violin()+
  theme_bw()

jpeg(paste("Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/Asmi_Excel/Yearly Summaries/",
              currentyr,"_asmi/Fig4b.jpg", sep = ""),
         units = "mm", res = 300, height = 100, width = 130)

ggplot(yrsaliveall[yrsaliveall$AsMi_site_id > 3,], aes(YrsD, Yearsalive, colour= as.factor(AsMi_site_id)))+
  # geom_jitter()+
  stat_smooth()+
  theme_bw()+
  scale_color_discrete(name = "Site")+
  xlab("Consecutive years dormant")+
  ylab("Life Length")

dev.off()
```

## 2021 attempt at imputation of stage and lengths for dormants
## Frequentist approximation of length given climate to impute some lengths for dormant. Need some measure of last time seen or go through if dormant previous year or years since last seen above ground   
```{r}

asmi.climate.plot <- aggregate(asmi.c[,names(asmi.c) %in% grep(paste(c("tmin","tmax","ppt"),collapse="|"),
                                          names(asmi.c), value=TRUE)],
                               asmi.c[,c("season","Creek","Prev12","Plot","Site","Site.1")],
                               function(x) mean(x, na.rm=TRUE))

seasonXplot <- reshape(asmi.climate.plot[asmi.climate.plot$Prev12 < currentyr+1 & asmi.climate.plot$Prev12 > 1994,],
                  idvar=c("Creek","Prev12","Plot","Site","Site.1"),
                  timevar = "season",
                  direction="wide")

# asmi.raw.climate <- merge(asmi.all2, asmi.climate.plot, by.x = c("year","plot","site"), by.y = c("Prev12","Plot","Site"))
asmi.raw.climate <- merge(asmi.all2, seasonXplot, by.x = c("year","plot","site"), 
                          by.y = c("Prev12","Plot","Site"))

asmi.raw.climate[asmi.raw.climate$length1 < 1,]

## length ~ stage and climate
lm1 <- glmer(length1 ~ length + (1|year), family = Gamma(link = "log"),
             data = asmi.raw.climate[asmi.raw.climate$length > 0 & asmi.raw.climate$length1 > 0,])
summary(lm1)


# library(nnet)
# multinom(fate ~ ppt.springSummer + stage, asmi.raw.climate)
# 
# lm1 <- multinom(status ~ ppt.fall + ppt.winter + ppt.springSummer +
#             tmax.winter + tmax.fall + tmax.springSummer +
#             tmin.springSummer + tmin.fall + tmin.winter, aic.asmi)
# lm2 <- multinom(status ~ ppt.springSummer, aic.asmi)
# lm3 <- multinom(status ~ tmin.winter + tmax.springSummer, aic.asmi) 
# lm4 <- multinom(status ~ ppt.winter, aic.asmi)
# lm5 <- multinom(status ~ 1, aic.asmi)
# lm6 <- multinom(status ~ AsMi_site_id, aic.asmi)
# # lm7 <- multinom(Lmda ~ Prev12, aic.asmi)
# lm7 <- multinom(status ~ year, aic.asmi)
# lm8 <- multinom(status ~ ppt.fall + ppt.winter +
#             tmax.winter + tmax.fall +  tmax.springSummer +
#             tmin.fall + tmin.winter, aic.asmi)
# lm9 <- multinom(status ~ ppt.winter*tmax.winter*tmin.winter, aic.asmi)
# lm10 <- multinom(status ~ ppt.fall*tmax.fall*tmin.fall, aic.asmi)
# lm11 <- multinom(status ~ ppt.fall*ppt.winter*tmax.winter*tmax.fall*tmax.springSummer*tmin.fall*tmin.winter, aic.asmi)
# # lm1,
# lm.list <- list(lm2, lm3, lm4, lm5, lm6, lm7, lm8, lm9, lm10, lm11)
# lm.names <- as.character(unlist(lapply(lm.list,formula)))
# (lm.results <- aictab(lm.list, modnames=lm.names))
# #evidence ratio 
# for(i in 2:length(lm.list)){
#   print(exp(0.5*lm.results$Delta_AICc[i]))
# }

```

# 2021
## Discussion
## biotic or climate driven dormancy, reproduction, recruitment  
```{r}
ps.asmi.lag.climate <- merge(ps.asmi.lag,  seasonXplot, by.x = c("Year.y","Plot","Site", "Creek"), # link to next year.y from previous 12 months climate to .y
                          by.y = c("Prev12","Plot","Site","Creek"))

glm1 <- glm(Total.Alive.y ~ X..Browsed.x, family = poisson(link = 'log'), data = ps.asmi.lag.climate) # AGG ~ br last year
glm2 <- glm(Total.Alive.y ~ X..Flowered.x, family = poisson(link = 'log'), data = ps.asmi.lag.climate) # ~ percent flower last year
glm3 <- glm(Total.Alive.y ~ Total.Alive.x, family = poisson(link = 'log'), data = ps.asmi.lag.climate) # ~ AGG last year
glm4 <- glm(Total.Alive.y ~  X..Browsed.x * Fence, family = poisson(link = 'log'), data = ps.asmi.lag.climate)
glm5 <- glm(Total.Alive.y ~ 1, family = poisson(link = 'log'), data = ps.asmi.lag.climate)
glm6 <- glm(Total.Alive.y ~ X..Browsed.y, family = poisson(link = 'log'), data = ps.asmi.lag.climate) # br in current year
glm7 <- glm(Total.Alive.y ~ X..Browsed.y * Fence, family = poisson(link = 'log'), data = ps.asmi.lag.climate) 
glm8 <- glm(Total.Alive.y ~ Total.Alive.x * X..Browsed.x, family = poisson(link = 'log'), data = ps.asmi.lag.climate)

glm9 <- glm(Total.Alive.y ~ ppt.fall*ppt.springSummer*ppt.winter, family = poisson(link = 'log'), data = ps.asmi.lag.climate) # AGG ~ br last year
glm10 <- glm(Total.Alive.y ~ ppt.fall*ppt.springSummer, family = poisson(link = 'log'), data = ps.asmi.lag.climate) # ~ percent flower last year
glm11 <- glm(Total.Alive.y ~ ppt.springSummer*ppt.winter, family = poisson(link = 'log'), data = ps.asmi.lag.climate) # ~ AGG last year
glm12 <- glm(Total.Alive.y ~  ppt.fall*ppt.winter * Fence, family = poisson(link = 'log'), data = ps.asmi.lag.climate)
glm13 <- glm(Total.Alive.y ~ 1, family = poisson(link = 'log'), data = ps.asmi.lag.climate)
glm14 <- glm(Total.Alive.y ~ tmax.fall*tmax.springSummer*tmax.winter, family = poisson(link = 'log'), data = ps.asmi.lag.climate) 
glm15 <- glm(Total.Alive.y ~ tmax.fall*tmax.springSummer, family = poisson(link = 'log'), data = ps.asmi.lag.climate) 
glm16 <- glm(Total.Alive.y ~ tmax.springSummer*tmax.winter, family = poisson(link = 'log'), data = ps.asmi.lag.climate)
glm17 <- glm(Total.Alive.y ~ tmax.fall*tmax.winter, family = poisson(link = 'log'), data = ps.asmi.lag.climate)
glm18 <- glm(Total.Alive.y ~ tmax.winter, family = poisson(link = 'log'), data = ps.asmi.lag.climate)

glm.list <- list(glm1,glm2,glm3,glm4,glm5,glm6,glm7,glm8,glm9, glm10, glm11, glm12, glm13, glm14, glm15, glm16, glm17)
# glm.list <- list(glm9, glm10, glm11, glm12, glm13, glm14, glm15, glm16, glm17)
glm.names <- as.character(unlist(lapply(glm.list,formula)))
(glm.results <- aictab(glm.list, modnames=glm.names))

```





################################################################################################################
#########################   Run once per year!! ################################################################
# Download climate data  
###Environmental Data from PRISM:   
<http://prism.oregonstate.edu/explorer/>  
<https://github.com/ropensci/prism>

Process takes a while   
Can go back to folder and delete old provisional data to replace with more current   
```{r, eval = FALSE}
# Set wd for prism
prism_set_dl_dir("Q:/Research/All_Projects_by_Species/Astragalus SPECIES/Astragalus_microcymbus/PRISM_asmiclimate")

#Precipitation total, rain and snow
get_prism_monthlys(type="ppt", mon = 1:12, keepZip = FALSE, years = (currentyr-1):currentyr)

#Maximum temperature (average)
get_prism_monthlys(type="tmax", mon = 1:12, keepZip = FALSE, years = (currentyr-1):currentyr)

#Minimum temperature (average)
get_prism_monthlys(type="tmin", mon = 1:12, keepZip = FALSE, years = (currentyr-1):currentyr)

```

Error, didn't download
```{r, eval=FALSE}
get_prism_monthlys(type="ppt", mon = 9, keepZip = FALSE, years = 1996)
get_prism_monthlys(type="ppt", mon = 6, keepZip = FALSE, years = 1999)
get_prism_monthlys(type="ppt", mon = 8, keepZip = FALSE, years = 1999)
```



#########################################################################################################################
### Takes forever, just load and move on after first time
# Want Site, Year, Month, ppt, tmin, tmax
```{r, eval = FALSE}

m.ppt <- lapply(prism_archive_subset("ppt", "monthly", years = 1986:currentyr), function(x){
  x_rast <- pd_to_file(x)
  rastertemps <- raster(x_rast)
  data.frame(data = raster::extract(rastertemps, asmiLL[,c("coords.x1","coords.x2")]),
             date = x, Plot = asmiLL$asmilatlong.Tag__, site = asmiLL$asmilatlong.Tag_Commen)
})
m.tmax <- lapply(prism_archive_subset("tmax","monthly",years = 1986:currentyr), function(x){
  x_rast <- pd_to_file(x)
  rastertemps <- raster(x_rast)
  data.frame(data = raster::extract(rastertemps, asmiLL[,c("coords.x1","coords.x2")]),
             date = x, Plot = asmiLL$asmilatlong.Tag__, site = asmiLL$asmilatlong.Tag_Commen)
})
m.tmin <- lapply(prism_archive_subset("tmin","monthly",years = 1986:currentyr), function(x){
  x_rast <- pd_to_file(x)
  rastertemps <- raster(x_rast)
  data.frame(data = raster::extract(rastertemps, asmiLL[,c("coords.x1","coords.x2")]),
             date = x, Plot = asmiLL$asmilatlong.Tag__, site = asmiLL$asmilatlong.Tag_Commen)
})



mins.avg <- do.call(rbind, m.tmin)
maxs.avg <- do.call(rbind, m.tmax)
ppt.avg <- do.call(rbind, m.ppt)

asmi.climate <- rbind(do.call(rbind, m.tmin), 
                    do.call(rbind, m.tmax),
                    do.call(rbind, m.ppt))


asmi.climate.monthly <- asmi.climate %>%
  mutate(Year = as.numeric(substr(date,  (nchar(date)+1)-10,nchar(date)-6)),
         Month = as.numeric(substr(date, (nchar(date)+1)-6, nchar(date)-4)),
         # Make previous 12 months match year (previous to May survey)
         Prev12 = ifelse(Month > 7, Year+1, Year)) %>%
  #extract the climate variable name from the prism long name
  separate(date, sep = "_", into = c(NA,"Variable",NA,NA,NA,NA)) %>%
  # mutate(season = "winter") %>%
  mutate(season = case_when(Month %in% c(1,2,3,12) ~ "winter",
                            Month>3 & Month<8 ~ "springSummer",
                            Month>7 & Month<12 ~ "fall"))

asmi.c <- asmi.climate.monthly %>%
  pivot_wider(names_from = Variable, values_from = data)

asmi.climate.season.ppt <- asmi.climate.monthly %>%
  filter(Variable == "ppt") %>%
  group_by(Variable, site, Plot, season, Prev12) %>%
  dplyr::summarise(Value = sum(data), .groups = "keep") 
  
asmi.climate.season.temp <- asmi.climate.monthly %>%
  filter(Variable != "ppt") %>%
  group_by(Variable, Plot, site, season, Prev12) %>%
  dplyr::summarise(Value = mean(data), .groups = "keep")
  
asmi.season <- bind_rows(list(asmi.climate.season.ppt, asmi.climate.season.temp))
asmi.season.wide <- asmi.season %>%
  pivot_wider(names_from = c(Variable,season), values_from = Value)

asmi.annual.ppt <- asmi.climate.monthly %>%
  filter(Variable == "ppt") %>%
  group_by(Variable, Plot, site,Prev12) %>%
  dplyr::summarise(Value = sum(data), .groups = "keep")
  
asmi.annual.temp <- asmi.climate.monthly %>%
  filter(Variable != "ppt") %>%
  group_by(Variable, Plot, site, Prev12) %>%
  dplyr::summarise(Value = mean(data), .groups = "keep")

asmi.annual <- do.call(rbind, list(as.data.frame(asmi.annual.ppt),
                                   as.data.frame(asmi.annual.temp)))

```

```{r}

save(asmi.climate, file = paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_Data/asmi.climate", currentyr,".Rdata", sep=""))
save(asmi.annual, file = paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_Data/asmi.annual", currentyr,".Rdata", sep=""))
save(asmi.season, file = paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_Data/asmi.season", currentyr,".Rdata", sep=""))
save(asmi.season.wide, file = paste("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Astragalus-microcymbus/Astragalus-microcymbus_Data/asmi.season.wide", currentyr,".Rdata", sep=""))

```
#########################################################################################################################
#################################### only once per year #################################################################





<https://blogs.oracle.com/datascience/introduction-to-forecasting-with-arima-in-r> 

<https://www.analyticsvidhya.com/blog/2015/12/complete-tutorial-time-series-modeling/>

How to pick the values of p, q, and d
<https://stats.stackexchange.com/questions/10750/arma-modeling-in-r>

ARIMA <https://machinelearningmastery.com/gentle-introduction-box-jenkins-method-time-series-forecasting/> forecasting time series data    

Powerpoint for ARIMA <http://www.ghahramani.ca/uploads/1/7/0/4/17042208/box-jenkins-r-seminar.pdf> 
<https://ncss-wpengine.netdna-ssl.com/wp-content/themes/ncss/pdf/Procedures/NCSS/The_Box-Jenkins_Method.pdf>

<https://datascienceplus.com/time-series-analysis-using-arima-model-in-r/> 

