---
title: "State-space multi-state CJS"
author: "Michelle DePrenger-Levin"
date: "2023-09-28"
output: html_document
---


From ResearchGate   
# Servanty et al 2014
### Whooping cranes reintroduced population
```{r}
##################################################################
#Sabrina Servanty, Sarah J. Converse, and Larissa L. Bailey. 2014. 
#Demography of a reintroduced population: moving toward management models for an endangered species, the Whooping Crane. 
#Ecological Applications 24:927â€“937. http://dx.doi.org/10.1890/13-0559.1
#
#Supplement 1: JAGS code to fit the state-space implementation of a multi-state mark-recapture model and get demographic estimates. 
#Ecological Archives A024-054-S1. 
#
#Author(s)
#
#Sabrina Servanty
#Colorado Cooperative Fish and Wildlife Research Unit
#Colorado State University
#1474 Campus Delivery
#Fort Collins, CO 80523-1474
#E-mail: sab.servanty@free.fr
#
#Sarah J. Converse
#Patuxent Wildlife Research Center
#U.S. Geological Survey
#12100 Beech Forest Road
#Laurel, MD 20708
#E-mail: sconverse@usgs.gov
###################################################################


##################################"
# Input variables
# N: number of individuals
# Seasons: number of seasons the population is followed
# First: vector with date of first capture (N components)
# Last: vector of date of newly dead (equal to Seasons if not dead at the end of the data set)
# spring: vector of spring dates
# nspring: vector of dates that are not spring
# Spring: length of spring
# NSpring: length of nspring
# z: state matrix (N rows, Seasons columns). Has NA until first capture
# eh : matrix of encounter (N rows, Seasons columns). Has NA until first capture
# sex: sex predictor (male or female)
# rel: release predictor (UL or DAR)
# age: matrix of age (N rows, Seasons columns). Five age-classes. 
# nburn: number of burn-in iterations
# niter: number of iterations to generate
# Zst : matrix of inits for the states (N rows, Seasons columns). Has NA everywhere except when a bird is not seen.
## In this case look at the state the bird was previously observed and give a possible state the bird could have been seen (NOT newly dead!)
#### 

library (rjags)

##############################
##### JAGS model #############
##############################

cat("

model {

############################################
# States (S):
# 1: Captive
# 2: Unpaired
# 3: First time paired
# 4: Breeder
# 5: First time nester
# 6: Previously nester but not nesting this year
# 7: Nesting again
# 8: Newly dead
# 9: Dead
#################################################

# At first time step all individuals are in the captive state
# PHI0 is survival at time zero

PHI0[1]<- 1
PHI0[2]<- 0
PHI0[3]<- 0
PHI0[4]<- 0
PHI0[5]<- 0
PHI0[6]<- 0
PHI0[7]<- 0
PHI0[8]<- 0 
PHI0[9]<- 0 

##############################
# State-space model likelihood
################################
## phi: 4 dimensions, survival (state of, individual, survey, states) ???
## po: 3 dimensions (state, individual, survey) 
## z: 2 dimensions, (individual, survey)

for (i in 1:N) {
  z[i,First[i]] ~ dcat(PHI0[])          # z == true state, dcat(pi) has density of pi_x/sum(pi_i) 
  for (j in (First[i]+1):Last[i]) {     # from next season of each First capture:Last (columns)
    #State equation
      z[i,j]~dcat(phi[z[i,j-1],i,j-1,1:9]) # phi[state prev survey, individual, prev survey, states]
    #Observation equation
      eh[i,j]~dbern(po[z[i,j],i,j])        # encounter history, Bernoulli po == observation probability??
    }#end of loop on time
  } #end of loop on individual

############################################################
# STATE process: define probabilities of S(t+1) given S(t)
############################################################
      
  ###################################
  ##### Non-spring transition matrix
  ###################################
  # phi[state at t, not spring index, state at t+1]

  for (i in 1:N) {
    for (t in 1:(NSpring-1)) {
    # First index: states at t, last index:states at t+1; a row of the matrix
    phi [1,i,nspring[t],1] <- phiC[i,nspring[t]] * (1-psiC[i,nspring[t]])
    phi [1,i,nspring[t],2] <- phiC[i,nspring[t]] * psiC[i,nspring[t]]
    phi [1,i,nspring[t],3] <- 0
    phi [1,i,nspring[t],4] <- 0
    phi [1,i,nspring[t],5] <- 0
    phi [1,i,nspring[t],6] <- 0
    phi [1,i,nspring[t],7] <- 0
    phi [1,i,nspring[t],8] <- (1-phiC[i,nspring[t]])
    phi [1,i,nspring[t],9] <- 0

    phi [2,i,nspring[t],1] <- 0
    phi [2,i,nspring[t],2] <- phiU[i,nspring[t]] * (1-pP1[i,nspring[t]])
    phi [2,i,nspring[t],3] <- phiU[i,nspring[t]] * pP1[i,nspring[t]]
    phi [2,i,nspring[t],4] <- 0
    phi [2,i,nspring[t],5] <- 0
    phi [2,i,nspring[t],6] <- 0
    phi [2,i,nspring[t],7] <- 0
    phi [2,i,nspring[t],8] <- (1-phiU[i,nspring[t]])
    phi [2,i,nspring[t],9] <- 0

    phi [3,i,nspring[t],1] <- 0
    phi [3,i,nspring[t],2] <- 0
    phi [3,i,nspring[t],3] <- 0
    phi [3,i,nspring[t],4] <- phiP1[i,nspring[t]]
    phi [3,i,nspring[t],5] <- 0
    phi [3,i,nspring[t],6] <- 0
    phi [3,i,nspring[t],7] <- 0
    phi [3,i,nspring[t],8] <- (1-phiP1[i,nspring[t]])
    phi [3,i,nspring[t],9] <- 0

    phi [4,i,nspring[t],1] <- 0
    phi [4,i,nspring[t],2] <- 0
    phi [4,i,nspring[t],3] <- 0
    phi [4,i,nspring[t],4] <- phiB[i,nspring[t]]
    phi [4,i,nspring[t],5] <- 0
    phi [4,i,nspring[t],6] <- 0
    phi [4,i,nspring[t],7] <- 0
    phi [4,i,nspring[t],8] <- (1-phiB[i,nspring[t]])
    phi [4,i,nspring[t],9] <- 0

    phi [5,i,nspring[t],1] <- 0
    phi [5,i,nspring[t],2] <- 0
    phi [5,i,nspring[t],3] <- 0
    phi [5,i,nspring[t],4] <- 0
    phi [5,i,nspring[t],5] <- phiN1[i,nspring[t]]
    phi [5,i,nspring[t],6] <- 0
    phi [5,i,nspring[t],7] <- 0
    phi [5,i,nspring[t],8] <- (1-phiN1[i,nspring[t]])
    phi [5,i,nspring[t],9] <- 0

    phi [6,i,nspring[t],1] <- 0
    phi [6,i,nspring[t],2] <- 0
    phi [6,i,nspring[t],3] <- 0
    phi [6,i,nspring[t],4] <- 0
    phi [6,i,nspring[t],5] <- 0
    phi [6,i,nspring[t],6] <- phiPN[i,nspring[t]]
    phi [6,i,nspring[t],7] <- 0
    phi [6,i,nspring[t],8] <- (1-phiPN[i,nspring[t]])
    phi [6,i,nspring[t],9] <- 0

    phi [7,i,nspring[t],1] <- 0
    phi [7,i,nspring[t],2] <- 0
    phi [7,i,nspring[t],3] <- 0
    phi [7,i,nspring[t],4] <- 0
    phi [7,i,nspring[t],5] <- 0
    phi [7,i,nspring[t],6] <- 0
    phi [7,i,nspring[t],7] <- phiNa[i,nspring[t]]
    phi [7,i,nspring[t],8] <- (1-phiNa[i,nspring[t]])
    phi [7,i,nspring[t],9] <- 0

    phi [8,i,nspring[t],1] <- 0
    phi [8,i,nspring[t],2] <- 0
    phi [8,i,nspring[t],3] <- 0
    phi [8,i,nspring[t],4] <- 0
    phi [8,i,nspring[t],5] <- 0
    phi [8,i,nspring[t],6] <- 0
    phi [8,i,nspring[t],7] <- 0
    phi [8,i,nspring[t],8] <- 0
    phi [8,i,nspring[t],9] <- 1

    phi [9,i,nspring[t],1] <- 0
    phi [9,i,nspring[t],2] <- 0
    phi [9,i,nspring[t],3] <- 0
    phi [9,i,nspring[t],4] <- 0
    phi [9,i,nspring[t],5] <- 0
    phi [9,i,nspring[t],6] <- 0
    phi [9,i,nspring[t],7] <- 0
    phi [9,i,nspring[t],8] <- 0
    phi [9,i,nspring[t],9] <- 1
    }
  }

  ##############################
  ###Spring transition matrix
  ###############################

  for (i in 1:N) {
    for (t in 1:Spring) {   

    phi [1,i,spring[t],1] <- phiC[i,spring[t]] * (1-psiC[i,spring[t]])
    phi [1,i,spring[t],2] <- phiC[i,spring[t]] * psiC[i,spring[t]]
    phi [1,i,spring[t],3] <- 0
    phi [1,i,spring[t],4] <- 0
    phi [1,i,spring[t],5] <- 0
    phi [1,i,spring[t],6] <- 0
    phi [1,i,spring[t],7] <- 0
    phi [1,i,spring[t],8] <- (1-phiC[i,spring[t]])
    phi [1,i,spring[t],9] <- 0

    phi [2,i,spring[t],1] <- 0
    phi [2,i,spring[t],2] <- phiU[i,spring[t]] * (1-pP1[i,spring[t]])
    phi [2,i,spring[t],3] <- phiU[i,spring[t]] * pP1[i,spring[t]] * (1-pN1[1,i,spring[t]])
    phi [2,i,spring[t],4] <- 0
    phi [2,i,spring[t],5] <- phiU[i,spring[t]] * pP1[i,spring[t]] * pN1[1,i,spring[t]]
    phi [2,i,spring[t],6] <- 0
    phi [2,i,spring[t],7] <- 0
    phi [2,i,spring[t],8] <- (1-phiU[i,spring[t]])
    phi [2,i,spring[t],9] <- 0

    phi [3,i,spring[t],1] <- 0
    phi [3,i,spring[t],2] <- 0
    phi [3,i,spring[t],3] <- 0
    phi [3,i,spring[t],4] <- phiP1[i,spring[t]] * (1-pN1[2,i,spring[t]]) 
    phi [3,i,spring[t],5] <- phiP1[i,spring[t]] * pN1[2,i,spring[t]]
    phi [3,i,spring[t],6] <- 0
    phi [3,i,spring[t],7] <- 0
    phi [3,i,spring[t],8] <- (1-phiP1[i,spring[t]])
    phi [3,i,spring[t],9] <- 0

    phi [4,i,spring[t],1] <- 0
    phi [4,i,spring[t],2] <- 0
    phi [4,i,spring[t],3] <- 0
    phi [4,i,spring[t],4] <- phiB[i,spring[t]] * (1-pN1[3,i,spring[t]])
    phi [4,i,spring[t],5] <- phiB[i,spring[t]] * pN1[3,i,spring[t]]
    phi [4,i,spring[t],6] <- 0
    phi [4,i,spring[t],7] <- 0
    phi [4,i,spring[t],8] <- (1-phiB[i,spring[t]])
    phi [4,i,spring[t],9] <- 0

    phi [5,i,spring[t],1] <- 0
    phi [5,i,spring[t],2] <- 0
    phi [5,i,spring[t],3] <- 0
    phi [5,i,spring[t],4] <- 0
    phi [5,i,spring[t],5] <- 0
    phi [5,i,spring[t],6] <- phiN1[i,spring[t]]* (1-pNa[1,i,spring[t]])
    phi [5,i,spring[t],7] <- phiN1[i,spring[t]]* pNa[1,i,spring[t]]
    phi [5,i,spring[t],8] <- (1-phiN1[i,spring[t]])
    phi [5,i,spring[t],9] <- 0

    phi [6,i,spring[t],1] <- 0
    phi [6,i,spring[t],2] <- 0
    phi [6,i,spring[t],3] <- 0
    phi [6,i,spring[t],4] <- 0
    phi [6,i,spring[t],5] <- 0
    phi [6,i,spring[t],6] <- phiPN[i,spring[t]] * (1-pNa[2,i,spring[t]])
    phi [6,i,spring[t],7] <- phiPN[i,spring[t]] * pNa[2,i,spring[t]]
    phi [6,i,spring[t],8] <- (1-phiPN[i,spring[t]])
    phi [6,i,spring[t],9] <- 0

    phi [7,i,spring[t],1] <- 0
    phi [7,i,spring[t],2] <- 0
    phi [7,i,spring[t],3] <- 0
    phi [7,i,spring[t],4] <- 0
    phi [7,i,spring[t],5] <- 0
    phi [7,i,spring[t],6] <- phiNa[i,spring[t]] * (1-pNa[3,i,spring[t]])
    phi [7,i,spring[t],7] <- phiNa[i,spring[t]] * pNa[3,i,spring[t]]
    phi [7,i,spring[t],8] <- (1-phiNa[i,spring[t]])
    phi [7,i,spring[t],9] <- 0

    phi [8,i,spring[t],1] <- 0
    phi [8,i,spring[t],2] <- 0
    phi [8,i,spring[t],3] <- 0
    phi [8,i,spring[t],4] <- 0
    phi [8,i,spring[t],5] <- 0
    phi [8,i,spring[t],6] <- 0
    phi [8,i,spring[t],7] <- 0
    phi [8,i,spring[t],8] <- 0
    phi [8,i,spring[t],9] <- 1

    phi [9,i,spring[t],1] <- 0
    phi [9,i,spring[t],2] <- 0
    phi [9,i,spring[t],3] <- 0
    phi [9,i,spring[t],4] <- 0
    phi [9,i,spring[t],5] <- 0
    phi [9,i,spring[t],6] <- 0
    phi [9,i,spring[t],7] <- 0
    phi [9,i,spring[t],8] <- 0
    phi [9,i,spring[t],9] <- 1
    }
  }

###############################################################
# OBSERVATION process: Define probabilities of O(t) given S(t).
################################################################

for (i in 1:N) {
   for(t in 1:Seasons) {
    # First index: states at time t, second index: observations at time t 
   po[1,i,t] <- 1
   logit(po[2,i,t]) <- prand[1,i,t]
   logit(po[3,i,t]) <- prand[2,i,t]
   logit(po[4,i,t]) <- prand[3,i,t]
   logit(po[5,i,t]) <- prand[4,i,t]
   logit(po[6,i,t]) <- prand[5,i,t]
   logit(po[7,i,t]) <- prand[6,i,t]
   logit(po[8,i,t]) <- prand[7,i,t]
   po[9,i,t] <- 0
   }
}

########################################
########################################
# CONSTRAINTS  & PRIORS ON SURVIVAL
########################################
########################################

  ##################################################
  ##### Constraints on survival in the captive state
  ##################################################  
  for (i in 1:N) {
    for (t in 1:15) {
      logit(phiC[i,t]) <- phiS1[t]
      }
    for (t in 16:(Seasons-1)) {
      logit(phiC[i,t]) <- phirel[1,rel[i]] + phiS1[t]
      }  
  }

  # Prior for time random effect
  for (t in 1:(Seasons-1)) {
    phiS1[t] ~ dnorm(intphiC,tauphiC)
    }
 
  intphiC ~ dunif(-10,10)
  tauphiC <- pow(sigphiC, -2)
  sigphiC ~ dunif(0,20)

  ##################################################
  ### Constraints on survival in the unpaired state
  ##################################################
  for (i in 1:N) {
    for (t in 1:4) {
      phiU[i,nspring[t]] <- 0
      }
    for (t in 5:15) { 
      logit(phiU[i,nspring[t]]) <- phisex[1,sex[i]] + phiS2[nspring[t]]
      }
    for (t in 16:(NSpring-1)) {     
      logit(phiU[i,nspring[t]]) <- phisex[1,sex[i]] + phirel[2,rel[i]] + phiS2[nspring[t]]
      }       
  }
  
  for (i in 1:N) {
    for (t in 1:Spring) { 
  	logit(phiU[i,spring[t]]) <- phisex[1,sex[i]] + phirel[2,rel[i]] + phiS2[spring[t]]
    }
  }

  # Prior for time random effect
  for (t in 5:(Seasons-1)) {     
    phiS2[t] ~ dnorm(intphiU,tauphiU)
    }

    intphiU ~ dunif(-10,10)
    tauphiU <- pow(sigphiU, -2)
    sigphiU ~ dunif(0,20)

  ###########################################################
  ### Constraints on survival in the first time paired state
  ##########################################################
  for (i in 1:N) {
    for (t in 1:5) {  
        phiP1[i,nspring[t]] <- 0
        }
    for (t in 6:(NSpring-1)) { 
       logit(phiP1[i,nspring[t]]) <- phisex[2,sex[i]] + phiS3[nspring[t]]
       }
  }
  
  for (i in 1:N) {
    for (t in 1:Spring) { 
  	logit(phiP1[i,spring[t]]) <- phisex[2,sex[i]] + phiS3[spring[t]]
       }
    }
  
  # Prior fot time random effect
  for (t in 6:(Seasons-1)) { 
    phiS3[t] ~ dnorm(intphiP1,tauphiP1)
    }
   	
      intphiP1 ~ dunif(-20,20)
      tauphiP1 <- pow(sigphiP1, -2)
     	sigphiP1 ~ dunif(0,20)

  
  ###########################################################
  ### Constraints on survival in the established paired state
  ###########################################################
  for (i in 1:N) {
    for (t in 1:6) {  
        phiB[i,nspring[t]] <- 0
        }
    for (t in 7:(NSpring-1)) {   
       logit(phiB[i,nspring[t]]) <- phisex[3,sex[i]] + phiS4[nspring[t]]
       }
    }
  
  for (i in 1:N) {
    for (t in 1:Spring) { 
  	logit(phiB[i,spring[t]]) <- phisex[3,sex[i]] + phiS4[spring[t]]
       }
    }
  
  # Prior for time random effect 
  for (t in 7:(Seasons-1)) { 
     phiS4[t] ~ dnorm(intphiB,tauphiB)
     }
  
      intphiB ~ dunif(-10,10)
     	tauphiB <- pow(sigphiB, -2)
      sigphiB ~ dunif(0,20)

  ##########################################################
  ### Constraints on survival in the first time nester state
  ##########################################################
  
  #Constraints for non spring
  for (i in 1:N) {
    for (t in 1:15) {
      phiN1[i,nspring[t]] <- 0
      }
  } 

  for (i in 1:N) {
    for (t in 16:(NSpring-1)) { 
       logit(phiN1[i,nspring[t]]) <- phisex[4,sex[i]] + phiS5[nspring[t]]
       }
    }
  
  # Constraints for spring seasons
  for (i in 1:N) {
    phiN1[i,spring[1]] <- 0 
    for (t in 2:Spring) { 
      logit(phiN1[i,spring[t]]) <- phisex[4,sex[i]] + phiS5[spring[t]]
      }
  }
  
  
  # Time random effect for nester for the first time
  for (t in 17:(Seasons-1)) {
     phiS5[t] ~ dnorm(intphiN1,tauphiN1)
     }
  
      intphiN1 ~ dunif(-10,10)
      tauphiN1 <- pow(sigphiN1, -2)
      sigphiN1 ~ dunif(0,20)     
  
  ############################################################################
  ### Constraints on survival in the non nesting again or nesting again state
  ############################################################################
  
  #Constraints during non spring seasons
  for (i in 1:N) {
    for (t in 1:18) {  
        phiPN[i,nspring[t]] <- 0
        phiNa[i,nspring[t]] <- 0
        }
    for (t in 19:(NSpring-1)) {
       logit(phiPN[i,nspring[t]]) <- phiS6[1,nspring[t]] # Non nesting again
       logit(phiNa[i,nspring[t]]) <- phisex[5,sex[i]] + phiS6[2,nspring[t]]  # Nesting again
       }    
  }
  
  #Constraints during spring
  for (i in 1:N) {                                
    for (t in 1:2) {
  	 phiPN[i,spring[t]] <- 0
  	 phiNa[i,spring[t]] <- 0
  	}
  	for (t in 3:Spring) {
  	logit(phiPN[i,spring[t]]) <- phiS6[1,spring[t]]
    logit(phiNa[i,spring[t]]) <- phisex[5,sex[i]] + phiS6[2,spring[t]]
  }
  }
  
  # Prior for time random effect   
  for (t in 21:(Seasons-1)) {
      phiS6[1,t] <- phiS6a[t-20]
      phiS6[2,t] <- phiS6b[t-20]
      }
    
  for (t in 1:15){
     phiS6a[t] ~ dnorm(intphiN[1],tauphiN[1]) # non nesting again
     phiS6b[t] ~ dnorm(intphiN[2],tauphiN[2]) # nesting again
  	} 
  
  for(s in 1:2){  
   intphiN[s] ~ dunif(-20,20)
   tauphiN[s] <- pow(sigphiN[s], -2)
   sigphiN[s] ~ dunif(0,20) 
   }
 
#######################  
#sex effect on survival
########################
for (s in 1:5) {
  phisex[s,1] <- bphisex[s]
  phisex[s,2] <- (-1*bphisex[s])
  bphisex[s] ~ dunif(-10,10)
  }
  
###########################
#release effect on survival
###########################
for (s in 1:2) {
  phirel[s,1] <- bphirel[s]
  phirel[s,2] <- (-1*bphirel[s])
  bphirel[s] ~ dunif(-10,10)
  }
  
########################################
########################################
# CONSTRAINTS  & PRIORS ON TRANSITION
########################################
########################################
  
  ###################################################################
  ## Constraints on transition from the captive to the unpaired state
  ###################################################################
  
  for (i in 1:N) {
    for (t in 1:3) {
     psiC[i,nspring[t]] <- 0
     }
    for (t in 4:15) { 
      logit(psiC[i,nspring[t]]) <- psiS1[nspring[t]]
      }
    for (t in 16:(NSpring-1)) {  
      logit(psiC[i,nspring[t]]) <- psirel[rel[i]] + psiS1[nspring[t]]
      }  
    }
  
  for (i in 1:N) {
    for (t in 1:Spring) {  
      logit(psiC[i,spring[t]]) <- psirel[rel[i]] + psiS1[spring[t]]
      }
  }
  
  # Prior for time random effect  
  for (t in 4:(Seasons-1)) {
      psiS1[t]  ~ dnorm(intpsiC,taupsiC)
      }
  
      intpsiC ~ dunif (-17,17)
    	taupsiC <- pow(sigpsiC, -2)
    	sigpsiC ~ dunif(0,30)
  
  ####################################################################
  ####Constraint on transition from the unpaired to the first time paired state
  ###################################################################
  for (i in 1:N) {
    for (t in 1:4) {
     pP1[i,nspring[t]] <- 0
     }
    for (t in 5:(NSpring-1)) {  #length of nspring
      logit(pP1[i,nspring[t]]) <-  psisex[1,sex[i]] + psiS2[nspring[t]] + psiage[age[i,nspring[t]]]
      }
  }
  
    
  for (i in 1:N) {
    for (t in 1:Spring) {  #length of spring
      logit(pP1[i,spring[t]]) <-  psisex[1,sex[i]] + psiS2[spring[t]] + psiage[age[i,spring[t]]]
      }
    }
  
  # Prior for time random effect  
  for (t in 5:(Seasons-1)) {  
      psiS2[t]  ~ dnorm(intpsiB,taupsiB)
      }
  
      intpsiB ~ dunif (-17,17)
    	taupsiB <- pow(sigpsiB, -2)
    	sigpsiB ~ dunif(0,20)
  
  ####################################################################
  ####Constraint on transition to the first time nester state during spring
  ###################################################################
  for (i in 1:N) {
    for (t in 1:Spring) { 
      pN1[1,i,spring[t]] <- psiS3
      pN1[2,i,spring[t]] <- psiS4
      logit(pN1[3,i,spring[t]]) <- psisex[2,sex[i]] + psiS5[spring[t]]
      }
    }

  # Constant probability
  psiS3 ~ dunif (0,1) # probability to become first time nester when being unpaired
  psiS4 ~ dunif (0,1) # probability to become first time nester when being first time paired
  
  #Fixed time effect
  for (t in 1:Spring) {
    psiS5[spring[t]] <- psiS5a[t] # probability to become first time nester when being established paired
    psiS5a[t] ~  dunif(-10,10)
    }  
  
  ####################################################################
  ####Constraint on transition to the nesting again state during spring
  ###################################################################
  
  # Transition from first time nester to nesting again
  for (i in 1:N) {
  	pNa[1,i,spring[1]] <- 0  
    for (t in 2:Spring) {  
      logit(pNa[1,i,spring[t]]) <- psisex[3,sex[i]] + psiS6[spring[t]]
      }
  }
  
  # Prior for fixed time effect
  for (t in 2:Spring) {   
     psiS6[spring[t]] <- psiS6a[t-1]  
     }
     
  for (t in 1:(Spring-1)) {
    psiS6a[t] ~  dunif(-17,17)  # transition from first time nester to nesting again 
    }
  
  # Transition from PN to NA and from NA to NA
  for (i in 1:N) {
    for (t in 1:2) {
      pNa[2,i,spring[t]] <- 0 
      pNa[3,i,spring[t]] <- 0
      }
    for (t in 3:Spring) { 
      logit(pNa[2,i,spring[t]]) <- psiS7[1,spring[t]]
      logit(pNa[3,i,spring[t]]) <- psisex[4,sex[i]] + psiS7[2,spring[t]]
      }
  }
  
  # Prior for fixed time effect 
 	for (t in 3:Spring) {
     psiS7[1,spring[t]] <- psiS7a[t-2]
     psiS7[2,spring[t]] <- psiS7b[t-2]
     }
  
  for (t in 1:(Spring-2)) { 
     psiS7a[t] ~ dunif(-17,17)
     psiS7b[t] ~ dunif(-17,17) 
 	   }
  
###########################
#sex effect on transitions
###########################
for (s in 1:4) {
  psisex[s,1] <- bpsisex[s]
  psisex[s,2] <- (-1*bpsisex[s])
  bpsisex[s] ~ dunif (-10,10)
  }

###############################   
# release effect on transition
############################### 
psirel[1] <- bpsirel
psirel[2] <- (-1*bpsirel)
bpsirel ~ dunif (-17,17)
  
###############################  
# age effect on transition
###############################
for(a in 1:5) {
  psiage[a] <- bpsiage[a]
  bpsiage[a] ~ dunif(-17,17)
  }

psiage[6] <- -1*(bpsiage[1]+ bpsiage[2] + bpsiage[3] + bpsiage[4] + bpsiage[5])

####################################################
####################################################
# CONSTRAINTS  & PRIORS ON PROBABILITY OF RECAPTURE
####################################################
####################################################

  # time random effect
  for (k in 1:7) {
    for (i in 1:N) {
      for (t in 1:Seasons) {
        prand[k,i,t] ~ dnorm(intp[k], taup[k])
        }
    }
  intp[k] ~ dunif (-20,20) 
  taup[k] <- pow(sigp[k], -2)
  sigp[k] ~ dunif (0,30)  
  }
     
 
}
  ",file = "Crane-model.txt")
  
#############################
#############################
# bundle data
############################# 
############################# 
bugs.data <- list (z=z, N = N, First = First, Last = Last, eh = eh, Seasons = Seasons, sex = sex, rel = rel, 
    age = age2, spring = spring, nspring = nspring, Spring = Spring, NSpring = NSpring)
  
#############################  
#############################    
# inits
#############################  
#############################    
inits <- function () {
  list(z=Zst, bphisex = runif(5,-5,5), bphirel = runif(2,-5,5), 
    intphiC = runif(1,-5,5), sigphiC = runif(1,0,10), 
    intphiU = runif(1,-5,5), sigphiU = runif(1,0,10), phiS2 = c(rep(NA,4),rnorm(31,0,1)),
    intphiP1 = runif(1,-5,5), sigphiP1 = runif(1,0,10), phiS3 = c(rep(NA,5),rnorm(30,0,1)),	
  	intphiB = runif(1,-5,5), sigphiB = runif(1,0,10), phiS4 = c(rep(NA,6),rnorm(29,0,1)),
    intphiN1 = runif(1,-5,5), sigphiN1 = runif(1,0,10), phiS5 = c(rep(NA,16),rnorm(19,0,1)), 
    intphiN = runif(2,-5,5), sigphiN = runif(2,0,10),  
    bpsisex = runif(4,-5,5), bpsirel = runif(1,-5,5),
	  intpsiC = runif(1,-5,5), sigpsiC = runif(1,0,10), psiS1 = c(rep(NA,3),rnorm(32,0,1)),
    intpsiB = runif (1,-5,5), sigpsiB = runif(1,0,10), psiS2 = c(rep(NA,4),rnorm(31,0,1)),  
    bpsiage = runif(5,-5,5), 
	  intp = runif(7,-5,5), sigp = runif(7,0,10))
}

#############################   	  
#############################   
# Define parameters to be monitored 
#############################   
#############################   
parameters <- c ("bphisex", "bphirel", "bpsisex", "bpsirel", "bpsiage", "intp", "sigp", 
  "intphiC",	"sigphiC",  
  "intphiU", "sigphiU", 
  "intphiP1", "sigphiP1",  
  "intphiB", "sigphiB",  
  "intphiN1", "sigphiN1",
  "intphiN", "sigphiN",
  "intpsiC", "sigpsiC",  
  "intpsiB", "sigpsiB",  
  "psiS3", "psiS4", "psiS5a", "psiS6a", "psiS7a","psiS7b")


# MCMC settings                                                                                                                                                     
out1 <- jags.model("Crane-model.txt", bugs.data, inits, n.chains=3, n.adapt=100)                                                                                                                                                                                  
update(out1, n.burn=nburn)                                                                                                   
out2 <- coda.samples(out1,parameters,n.iter=niter)                                                                                                                                                                                                                             
                                                                                                                                                                                                 
save(out2,file="crane.Rdata")
```


```

